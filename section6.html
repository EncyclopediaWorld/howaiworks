<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Section VI — The Deep Learning Explosion · How AI Works</title>
<link rel="stylesheet" href="styles.css">
</head><body>
<div class="progress-bar" style="background:linear-gradient(90deg,var(--a5),var(--a6))"></div>
<button class="back-top" onclick="window.scrollTo({top:0,behavior:'smooth'})">↑</button>
<nav class="topnav"><a href="index.html" class="logo">How AI Works</a><div class="nav-links"><a href="section1.html">I</a><a href="section2.html">II</a><a href="section3.html">III</a><a href="section4.html">IV</a><a href="section5.html">V</a><a href="section6.html" class="active">VI</a><a href="section7.html">VII</a><a href="section8.html">VIII</a></div></nav>
<div class="section-hero"><div class="era-label" style="color:var(--a5)">Section VI · 2012–2015</div>
<h1>The Deep Learning Explosion</h1><p>AlexNet triggers the revolution. GANs, attention, ResNets, and Word2Vec reshape AI forever.</p>
<div class="nav-arrows"><a href="section5.html">&larr; Section V</a><a href="section7.html">Section VII &rarr;</a></div></div>
<div class="models-container">

<!-- ======= ALEXNET ======= -->
<div class="model-card" id="model-alexnet"><div class="mc-head"><span class="mc-year" style="color:var(--a5)">2012</span><div class="mc-info">
<h3>AlexNet <a href="https://papers.nips.cc/paper/2012/hash/c399862d3b9d6b76c8436e924a68c45b-Abstract.html" target="_blank" class="paper-link">Paper</a></h3>
<p>Krizhevsky's CNN crushed ImageNet by 10%. Deeper than LeNet with ReLU, dropout, and GPU training. Proved deep learning works at scale.</p>
<div class="model-lineage">Scales <a href="section4.html#model-cnn">CNN/LeNet</a> with <a href="section6.html#model-dropout">Dropout</a> and GPU power; its ImageNet victory ignites the deep learning era leading to <a href="section6.html#model-resnet">ResNet</a> and <a href="section8.html#model-vit">ViT</a>.</div>
</div></div>
<div class="mc-formula" style="color:var(--a5)">227×227 → Conv(96) → Pool → Conv(256) → Pool → Conv(384) → Conv(384) → Conv(256) → FC → 1000 classes</div>
<div class="mc-demo" id="demo-alex"></div></div>

<!-- ======= DROPOUT ======= -->
<div class="model-card" id="model-dropout"><div class="mc-head"><span class="mc-year" style="color:var(--a5)">2014</span><div class="mc-info">
<h3>Dropout <a href="https://jmlr.org/papers/v15/srivastava14a.html" target="_blank" class="paper-link">Paper</a></h3>
<p>Randomly "kill" neurons during training. Forces the network to not rely on any single neuron — like training an ensemble of sub-networks.</p>
<div class="model-lineage">Key regularization technique first used in <a href="section6.html#model-alexnet">AlexNet</a>; prevents overfitting in all deep networks from <a href="section6.html#model-resnet">ResNet</a> to <a href="section7.html#model-transformer">Transformer</a>.</div>
</div></div>
<div class="mc-formula" style="color:var(--a5)">During training: hᵢ = hᵢ × Bernoulli(p) — each neuron dropped with probability (1-p)</div>
<div class="mc-demo" id="demo-drop"></div></div>

<!-- ======= WORD2VEC ======= -->
<div class="model-card" id="model-word2vec"><div class="mc-head"><span class="mc-year" style="color:var(--a5)">2013</span><div class="mc-info">
<h3>Word2Vec <a href="https://arxiv.org/abs/1301.3781" target="_blank" class="paper-link">Paper</a></h3>
<p>Mikolov's word embeddings — learn vector representations where semantic relationships become arithmetic: King − Man + Woman ≈ Queen.</p>
<div class="model-lineage">Simplifies <a href="section5.html#model-nnlm">NNLM</a> into efficient embedding training; its dense vectors become the input layer for <a href="section7.html#model-elmo">ELMo</a>, <a href="section7.html#model-bert">BERT</a>, and all modern NLP.</div>
</div></div>
<div class="mc-formula" style="color:var(--a5)">king − man + woman ≈ queen — semantic arithmetic in vector space!</div>
<div class="mc-demo" id="demo-w2v"></div></div>

<!-- ======= VAE ======= -->
<div class="model-card" id="model-vae"><div class="mc-head"><span class="mc-year" style="color:var(--a5)">2013</span><div class="mc-info">
<h3>VAE (Variational Autoencoder) <a href="https://arxiv.org/abs/1312.6114" target="_blank" class="paper-link">Paper</a></h3>
<p>Kingma's generative model — encode data into a smooth latent distribution, sample, and decode. The latent space is continuous and interpolatable.</p>
<div class="model-lineage">Adds probabilistic sampling to <a href="section5.html#model-sparse-ae">Sparse Autoencoder</a> using <a href="section4.html#model-gmm">GMM+EM</a>'s variational ideas; its latent space concept flows into <a href="section8.html#model-diffusion">Diffusion Models</a>.</div>
</div></div>
<div class="mc-formula" style="color:var(--a5)">Encode: x → (μ, σ²) → sample z ~ N(μ,σ²) → Decode: z → x̂ — smooth generative latent space</div>
<div class="mc-demo" id="demo-vae"></div></div>

<!-- ======= GAN ======= -->
<div class="model-card" id="model-gan"><div class="mc-head"><span class="mc-year" style="color:var(--a5)">2014</span><div class="mc-info">
<h3>GAN (Generative Adversarial Network) <a href="https://arxiv.org/abs/1406.2661" target="_blank" class="paper-link">Paper</a></h3>
<p>Goodfellow's brilliant idea — two networks competing: Generator creates fakes, Discriminator judges real vs fake. They push each other to improve.</p>
<div class="model-lineage">A new generative paradigm rivaling <a href="section6.html#model-vae">VAE</a>; leads to <a href="section7.html#model-stylegan">StyleGAN</a> for photorealistic faces, later surpassed by <a href="section8.html#model-diffusion">Diffusion Models</a>.</div>
</div></div>
<div class="mc-formula" style="color:var(--a5)">min_G max_D [E log D(x) + E log(1-D(G(z)))] — Generator vs Discriminator game</div>
<div class="mc-demo" id="demo-gan"></div></div>

<!-- ======= SEQ2SEQ ======= -->
<div class="model-card" id="model-seq2seq"><div class="mc-head"><span class="mc-year" style="color:var(--a5)">2014</span><div class="mc-info">
<h3>Seq2Seq + Attention <a href="https://arxiv.org/abs/1409.0473" target="_blank" class="paper-link">Paper</a></h3>
<p>Bahdanau's attention mechanism — let the decoder LOOK BACK at relevant input parts at each step. Revolutionary for translation.</p>
<div class="model-lineage">Extends <a href="section4.html#model-lstm">LSTM</a> encoder-decoder with attention; this attention idea is generalized into the pure-attention <a href="section7.html#model-transformer">Transformer</a>.</div>
</div></div>
<div class="mc-formula" style="color:var(--a5)">attention(Q,K) = softmax(Q·Kᵀ) · V — focus on relevant input words for each output word</div>
<div class="mc-demo" id="demo-attn"></div></div>

<!-- ======= RESNET ======= -->
<div class="model-card" id="model-resnet"><div class="mc-head"><span class="mc-year" style="color:var(--a5)">2015</span><div class="mc-info">
<h3>ResNet (Residual Network) <a href="https://arxiv.org/abs/1512.03385" target="_blank" class="paper-link">Paper</a></h3>
<p>He's skip connections — learn the residual F(x) = H(x) − x. Output = F(x) + x. Lets gradients flow through shortcuts, enabling 152+ layers.</p>
<div class="model-lineage">Solves the depth problem of <a href="section6.html#model-alexnet">AlexNet</a> with skip connections; its residual design is adopted by <a href="section7.html#model-transformer">Transformer</a> and <a href="section8.html#model-vit">ViT</a>.</div>
</div></div>
<div class="mc-formula" style="color:var(--a5)">output = F(x) + x — skip connection lets gradient flow through identity shortcut</div>
<div class="mc-demo" id="demo-resnet"></div></div>

<!-- ======= BATCHNORM ======= -->
<div class="model-card" id="model-batchnorm"><div class="mc-head"><span class="mc-year" style="color:var(--a5)">2015</span><div class="mc-info">
<h3>Batch Normalization <a href="https://arxiv.org/abs/1502.03167" target="_blank" class="paper-link">Paper</a></h3>
<p>Ioffe & Szegedy — normalize each layer's inputs to zero mean and unit variance. Speeds up training and allows higher learning rates.</p>
<div class="model-lineage">Stabilizes deep network training for <a href="section6.html#model-resnet">ResNet</a> and beyond; adapted as LayerNorm in <a href="section7.html#model-transformer">Transformer</a> and all modern architectures.</div>
</div></div>
<div class="mc-formula" style="color:var(--a5)">x̂ = (x − μ_batch) / √(σ²_batch + ε) · γ + β — normalize, then scale and shift (learnable)</div>
<div class="mc-demo" id="demo-bn"></div></div>

</div>
<footer><a href="section5.html">&larr; Section V</a> &middot; <a href="section7.html">Section VII: The Transformer Revolution &rarr;</a></footer>
<script src="shared.js"></script>
<script>
// ===== ALEXNET =====
(function(){const el=$('demo-alex'),[c,ctx]=createCanvas(el,750,340);
addHint(el,'Click "Feed Image" to watch a photo flow through the layers. See spatial size shrink and feature channels multiply!');
// Simulated 8x8 "image" input with recognizable pattern (a simple face-like pattern)
const inputImg=[];
for(let r=0;r<8;r++) for(let ci=0;ci<8;ci++){
  let v=0;
  // Eyes
  if((r===2||r===3)&&(ci===1||ci===2))v=0.9;
  if((r===2||r===3)&&(ci===5||ci===6))v=0.9;
  // Nose
  if((r===4)&&(ci===3||ci===4))v=0.6;
  // Mouth
  if(r===6&&ci>=2&&ci<=5)v=0.8;
  if(r===5&&(ci===2||ci===5))v=0.5;
  // Background
  if(v===0)v=rand(0.05,0.2);
  inputImg.push(v);
}
// Simulated feature maps for each layer (generated from input)
function makeFeatureMaps(input,nMaps,size,layerIdx){
  const maps=[];
  for(let m=0;m<nMaps;m++){
    const fm=[];
    for(let r=0;r<size;r++) for(let ci=0;ci<size;ci++){
      let v=0;
      // Each filter detects different things
      if(layerIdx===0){// Conv1: edge detectors
        let ir=Math.floor(r/size*8),ic=Math.floor(ci/size*8);
        if(m%3===0) v=Math.abs((input[ir*8+Math.min(ic+1,7)]||0)-(input[ir*8+ic]||0))*3;// horizontal edge
        else if(m%3===1) v=Math.abs((input[Math.min(ir+1,7)*8+ic]||0)-(input[ir*8+ic]||0))*3;// vertical edge
        else v=(input[ir*8+ic]||0)*Math.sin(m*0.5+r*ci)*0.5+0.5;
      } else {
        v=Math.sin((m+1)*(r+1)*0.4)*0.3+Math.cos((m+1)*(ci+1)*0.5)*0.3+0.4;
        v+=rand(-0.1,0.1);
      }
      fm.push(clamp(v,0,1));
    }
    maps.push(fm);
  }
  return maps;
}
const layers=[
  {name:'Input',size:8,maps:1,c:'#38bdf8',desc:'8\u00d78 grayscale image'},
  {name:'Conv1+ReLU',size:6,maps:4,c:'#ff6b6b',desc:'Edge detection (4 filters)'},
  {name:'MaxPool',size:3,maps:4,c:'#ffd166',desc:'Shrink 2\u00d7, keep strongest'},
  {name:'Conv2+ReLU',size:3,maps:6,c:'#4ecdc4',desc:'Texture patterns (6 filters)'},
  {name:'Flatten+FC',size:1,maps:8,c:'#a78bfa',desc:'8 neurons, fully connected'},
  {name:'Output',size:1,maps:3,c:'#34d399',desc:'3 classes: face/cat/car'}
];
const fmaps=[];
fmaps.push([inputImg]);
fmaps.push(makeFeatureMaps(inputImg,4,6,0));
// MaxPool: take every other pixel
let pooled=fmaps[1].map(fm=>{let p=[];for(let r=0;r<3;r++)for(let ci=0;ci<3;ci++){
  let vals=[fm[r*2*6+ci*2],fm[r*2*6+ci*2+1],fm[(r*2+1)*6+ci*2],fm[(r*2+1)*6+ci*2+1]];
  p.push(Math.max(...vals));}return p;});
fmaps.push(pooled);
fmaps.push(makeFeatureMaps(inputImg,6,3,1));
// FC: single values
fmaps.push(Array.from({length:8},(_,i)=>[sigmoid(Math.sin(i*1.5)*2)]));
// Output: probabilities
fmaps.push([[0.82],[0.12],[0.06]]);
const outLabels=['Face','Cat','Car'];

let activeLayer=-1,animT=0,animId=null;
function startFeed(){activeLayer=-1;animT=0;if(animId)cancelAnimationFrame(animId);
  (function tick(){animT+=0.012;activeLayer=Math.floor(animT*layers.length/1.0);
    if(activeLayer>=layers.length)activeLayer=layers.length-1;
    draw();if(animT<1.2)animId=requestAnimationFrame(tick);else animId=null;})();}

function draw(){ctx.clearRect(0,0,750,340);
  const colW=120,startX=10;
  layers.forEach((L,li)=>{
    const x=startX+li*colW,y=10;
    const isActive=li<=activeLayer;
    const isHighlight=li===activeLayer;
    // Column header
    ctx.fillStyle=isActive?L.c:'#4a475a';ctx.font=(isHighlight?'700':'500')+' 9px Fira Code';
    ctx.textAlign='center';ctx.fillText(L.name,x+colW/2,y+10);
    ctx.textAlign='left';
    // Feature maps grid
    const maps=fmaps[li];
    const nMaps=maps.length;
    const cols=li===0?1:Math.min(nMaps,Math.ceil(Math.sqrt(nMaps)));
    const rows=Math.ceil(nMaps/cols);
    const mapSize=L.size;
    const maxCellArea=(colW-12)*(190)/Math.max(nMaps,1);
    const cellPx=Math.min(Math.floor(Math.sqrt(maxCellArea)/mapSize),li===0?16:li<=2?14:li<=3?16:22);
    const totalMapW=cols*(mapSize*cellPx+4);
    const mStartX=x+(colW-totalMapW)/2;
    maps.forEach((fm,mi)=>{
      const mr=Math.floor(mi/cols),mc=mi%cols;
      const mx=mStartX+mc*(mapSize*cellPx+4);
      const my=y+18+mr*(mapSize*cellPx+4);
      // Background
      ctx.fillStyle='#08081a';ctx.fillRect(mx-1,my-1,mapSize*cellPx+2,mapSize*cellPx+2);
      if(isActive){
        for(let r=0;r<mapSize;r++) for(let ci=0;ci<mapSize;ci++){
          let v=fm[r*mapSize+ci];
          if(li===layers.length-1){// Output: color by class
            const colors=['#34d399','#ffd166','#ff6b6b'];
            ctx.fillStyle=colors[mi]+(Math.round(clamp(v,0.05,1)*230).toString(16).padStart(2,'0'));
          } else {
            ctx.fillStyle=L.c+(Math.round(clamp(v,0.05,1)*220).toString(16).padStart(2,'0'));
          }
          ctx.fillRect(mx+ci*cellPx,my+r*cellPx,cellPx-1,cellPx-1);
        }
      } else {
        ctx.fillStyle='#111125';ctx.fillRect(mx,my,mapSize*cellPx,mapSize*cellPx);
      }
    });
    // Output labels
    if(li===layers.length-1&&isActive){
      maps.forEach((fm,mi)=>{
        const mr=Math.floor(mi/cols),mc=mi%cols;
        const mx=mStartX+mc*(mapSize*cellPx+4);
        const my=y+18+mr*(mapSize*cellPx+4);
        ctx.fillStyle='#e4e2df';ctx.font='600 8px Fira Code';
        ctx.fillText(outLabels[mi]+': '+(fm[0]*100).toFixed(0)+'%',mx+cellPx+4,my+cellPx/2+3);
      });
    }
    // Description
    ctx.fillStyle=isActive?'#7d7a8c':'#333';ctx.font='400 7px Fira Code';ctx.textAlign='center';
    const descY=y+18+rows*(maps[0].length>1?L.size*(cellPx)+4:L.size*cellPx+4)+6;
    ctx.fillText(L.desc,x+colW/2,Math.min(descY,220));
    // Size annotation
    if(isActive&&li<layers.length-1){
      ctx.fillStyle=L.c;ctx.font='500 7px Fira Code';
      ctx.fillText(L.size+'\u00d7'+L.size+'\u00d7'+nMaps,x+colW/2,Math.min(descY+12,232));}
    ctx.textAlign='left';
    // Arrow between layers
    if(li<layers.length-1){
      ctx.fillStyle=isActive?'#4a475a':'#222';ctx.font='14px sans-serif';
      ctx.fillText('\u2192',x+colW-8,y+100);
      // Animated dot
      if(isHighlight&&animT>0){
        ctx.save();ctx.shadowColor=L.c;ctx.shadowBlur=8;
        let dotPhase=(animT*layers.length-li)%1;
        ctx.beginPath();ctx.arc(x+colW-8+12*dotPhase,y+99,3,0,TAU);ctx.fillStyle=L.c;ctx.fill();ctx.restore();
      }
    }
  });
  // Operation labels between columns
  const ops=['\u2b1b Conv\n3\u00d73 filters','MaxPool\n2\u00d72 stride','Conv\n3\u00d73','Flatten\n+ FC','Softmax'];
  ops.forEach((op,i)=>{
    const x=startX+(i+1)*colW-8;
    ctx.fillStyle=(i<activeLayer)?'#7d7a8c':'#333';ctx.font='400 6px Fira Code';ctx.textAlign='center';
    op.split('\n').forEach((line,li)=>ctx.fillText(line,x,244+li*10));
    ctx.textAlign='left';
  });
  // Bottom explanation
  ctx.fillStyle='rgba(6,6,12,.88)';ctx.beginPath();ctx.roundRect(15,270,720,62,8);ctx.fill();
  ctx.fillStyle='#ff6b6b';ctx.font='600 10px Fira Code';
  ctx.fillText('AlexNet (2012): Won ImageNet with 15.3% top-5 error (prev best: 26%)',25,288);
  ctx.fillStyle='#e4e2df';ctx.font='400 9px Fira Code';
  ctx.fillText('Each conv layer applies filters to detect features. Spatial size shrinks (8\u21926\u21923\u21921) while channels grow (1\u21924\u21926\u21928).',25,304);
  ctx.fillStyle='#7d7a8c';ctx.font='400 8px Fira Code';
  ctx.fillText('Key: ReLU activation (fast), Dropout (regularize), GPU training (speed), MaxPool (compress spatial info, keep strongest signals)',25,320);
}
const ctrl=addControls(el);
const fb=document.createElement('button');fb.className='btn';fb.textContent='\u25b6 Feed Image';fb.onclick=startFeed;
const rst=document.createElement('button');rst.className='btn';rst.textContent='\u21bb Reset';
rst.onclick=()=>{activeLayer=-1;if(animId){cancelAnimationFrame(animId);animId=null;}draw();};
ctrl.appendChild(fb);ctrl.appendChild(rst);draw()})();


// ===== DROPOUT =====
(function(){const el=$('demo-drop'),[c,ctx]=createCanvas(el,750,300);
addHint(el,'Toggle Training vs Inference. Drag the slider to change drop rate. "Resample" shows different masks.');
let mode='train',dropRate=.5;
const layers=[[0,1,2,3],[0,1,2,3,4,5],[0,1,2,3,4,5],[0,1,2,3]];
let masks=layers.map(l=>l.map(()=>Math.random()>dropRate?1:0));
function resample(){masks=layers.map(l=>l.map(()=>Math.random()>dropRate?1:0));draw();}
function draw(){ctx.clearRect(0,0,750,300);
let lx=[120,280,440,600],ly=140,labels=['Input','Hidden 1','Hidden 2','Output'],colors=['#38bdf8','#a78bfa','#fb923c','#34d399'];
for(let l=0;l<3;l++){layers[l].forEach((fi,fIdx)=>{layers[l+1].forEach((ti,tIdx)=>{
let fA=mode==='test'||masks[l][fIdx],tA=mode==='test'||masks[l+1][tIdx];
let fy=ly-layers[l].length*20+fIdx*40,ty=ly-layers[l+1].length*20+tIdx*40;
ctx.strokeStyle=fA&&tA?'rgba(255,255,255,.08)':'rgba(255,255,255,.015)';ctx.lineWidth=1;
ctx.beginPath();ctx.moveTo(lx[l],fy);ctx.lineTo(lx[l+1],ty);ctx.stroke()})});}
layers.forEach((layer,li)=>{layer.forEach((n,ni)=>{
let y=ly-layer.length*20+ni*40,active=mode==='test'||masks[li][ni];
ctx.save();if(active){ctx.shadowColor=colors[li];ctx.shadowBlur=10;}
ctx.beginPath();ctx.arc(lx[li],y,14,0,TAU);
ctx.fillStyle=active?colors[li]+'33':'#0c0c16';ctx.fill();
ctx.strokeStyle=active?colors[li]:'#333';ctx.lineWidth=active?2:1;ctx.stroke();ctx.restore();
if(!active){ctx.strokeStyle='#ff6b6b';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(lx[li]-8,y-8);ctx.lineTo(lx[li]+8,y+8);ctx.stroke();
ctx.beginPath();ctx.moveTo(lx[li]+8,y-8);ctx.lineTo(lx[li]-8,y+8);ctx.stroke();}
ctx.fillStyle=active?'#e4e2df':'#4a475a';ctx.font='bold 8px Fira Code';ctx.textAlign='center';
ctx.fillText(active?(mode==='test'?'×'+(1-dropRate).toFixed(1):'ON'):'OFF',lx[li],y+3);ctx.textAlign='left';})});
layers.forEach((l,i)=>{ctx.fillStyle=colors[i];ctx.font='500 9px Fira Code';ctx.textAlign='center';ctx.fillText(labels[i],lx[i],ly+l.length*20+20);ctx.textAlign='left';});
ctx.fillStyle='rgba(6,6,12,.9)';ctx.beginPath();ctx.roundRect(8,8,250,55,8);ctx.fill();
ctx.fillStyle=mode==='train'?'#ff6b6b':'#34d399';ctx.font='700 14px Fira Code';
ctx.fillText(mode==='train'?'\ud83c\udfb2 TRAINING':'\u2705 INFERENCE',18,30);
ctx.fillStyle='#7d7a8c';ctx.font='400 9px Fira Code';
ctx.fillText(mode==='train'?'Drop rate: '+(dropRate*100).toFixed(0)+'% \u2014 neurons randomly killed':'All active, weights \u00d7 '+(1-dropRate).toFixed(1)+' (keep prob)',18,50);
let active=masks.flat().filter(v=>v).length,total=masks.flat().length;
ctx.fillStyle='rgba(6,6,12,.85)';ctx.beginPath();ctx.roundRect(15,255,720,38,8);ctx.fill();
ctx.fillStyle='#ffd166';ctx.font='500 9px Fira Code';
ctx.fillText(mode==='train'?'Active: '+active+'/'+total+'. Each sample sees a DIFFERENT sub-network \u2192 ensemble effect!':
'Test: all neurons ON, outputs \u00d7 keep prob ('+(1-dropRate).toFixed(1)+') to match training scale.',25,278);}
const ctrl=addControls(el);
const mt=document.createElement('button');mt.className='btn active';mt.textContent='\ud83c\udfb2 Train';
const mi=document.createElement('button');mi.className='btn';mi.textContent='\u2705 Inference';
mt.onclick=()=>{mode='train';mt.classList.add('active');mi.classList.remove('active');resample();};
mi.onclick=()=>{mode='test';mi.classList.add('active');mt.classList.remove('active');draw();};
const rs=document.createElement('button');rs.className='btn';rs.textContent='\ud83c\udfb2 Resample';rs.onclick=resample;
// Dropout rate slider
const dlbl=document.createElement('label');dlbl.textContent='Rate';dlbl.style.cssText='color:#ff6b6b;font:500 10px Fira Code;margin-left:8px';
const dslider=document.createElement('input');dslider.type='range';dslider.min='10';dslider.max='90';dslider.value='50';dslider.style.cssText='width:80px;vertical-align:middle';
const dval=document.createElement('span');dval.className='btn';dval.style.cssText='min-width:38px;text-align:center;font-size:10px';dval.textContent='50%';
dslider.oninput=e=>{dropRate=e.target.value/100;dval.textContent=(dropRate*100).toFixed(0)+'%';resample();};
ctrl.appendChild(mt);ctrl.appendChild(mi);ctrl.appendChild(rs);ctrl.appendChild(dlbl);ctrl.appendChild(dslider);ctrl.appendChild(dval);draw()})();

// ===== WORD2VEC =====
(function(){const el=$('demo-w2v'),[c,ctx]=createCanvas(el,750,320);
addHint(el,'Click analogies to see semantic arithmetic in vector space.');
const words={king:[.9,.8],queen:[.9,-.8],man:[.3,.7],woman:[.3,-.7],prince:[.7,.5],princess:[.7,-.5],
dog:[-.6,.3],cat:[-.5,-.3],puppy:[-.4,.4],kitten:[-.3,-.2],
paris:[-.8,.6],france:[-.7,.8],berlin:[-.8,-.4],germany:[-.7,-.6],tokyo:[-.9,0],japan:[-.8,.1]};
const analogies=[
{a:'king',b:'man',c:'woman',result:'queen',desc:'Royalty: gender relationship'},
{a:'paris',b:'france',c:'germany',result:'berlin',desc:'Capital: country relationship'},
{a:'puppy',b:'dog',c:'cat',result:'kitten',desc:'Young: species relationship'},
{a:'prince',b:'man',c:'woman',result:'princess',desc:'Royal gender relationship'}];
let selAn=0;
function draw(){ctx.clearRect(0,0,750,320);let an=analogies[selAn];
analogies.forEach((a,i)=>{let x=15+i*183,y=8;
ctx.fillStyle=i===selAn?'rgba(244,114,182,.12)':'#0c0c16';ctx.beginPath();ctx.roundRect(x,y,176,28,5);ctx.fill();
ctx.strokeStyle=i===selAn?'#f472b6':'#1e1e32';ctx.lineWidth=i===selAn?2:1;ctx.beginPath();ctx.roundRect(x,y,176,28,5);ctx.stroke();
ctx.fillStyle=i===selAn?'#e4e2df':'#4a475a';ctx.font='500 9px Fira Code';ctx.fillText(a.a+' \u2212 '+a.b+' + '+a.c+' = ?',x+8,y+18);});
let cx2=220,cy2=180,scale=120;
ctx.strokeStyle='#1a1a2a';ctx.lineWidth=1;
ctx.beginPath();ctx.moveTo(cx2-180,cy2);ctx.lineTo(cx2+180,cy2);ctx.stroke();
ctx.beginPath();ctx.moveTo(cx2,cy2-130);ctx.lineTo(cx2,cy2+130);ctx.stroke();
Object.entries(words).forEach(([w,v])=>{let x=cx2+v[0]*scale,y=cy2-v[1]*scale;
let isA=w===an.a,isB=w===an.b,isC=w===an.c,isR=w===an.result,hl=isA||isB||isC||isR;
ctx.beginPath();ctx.arc(x,y,hl?7:3,0,TAU);
ctx.fillStyle=isA?'#ff6b6b':isB?'#38bdf8':isC?'#ffd166':isR?'#34d399':'#4a475a';ctx.fill();
if(hl){ctx.fillStyle=isA?'#ff6b6b':isB?'#38bdf8':isC?'#ffd166':'#34d399';
ctx.font='600 10px Fira Code';ctx.textAlign='center';ctx.fillText(w,x,y-12);ctx.textAlign='left';}
else{ctx.fillStyle='#4a475a';ctx.font='400 7px Fira Code';ctx.textAlign='center';ctx.fillText(w,x,y-6);ctx.textAlign='left';}});
let va=words[an.a],vb=words[an.b],vc=words[an.c],vr=words[an.result];
if(va&&vb&&vc&&vr){ctx.strokeStyle='#ff6b6b88';ctx.lineWidth=2;ctx.setLineDash([5,3]);
ctx.beginPath();ctx.moveTo(cx2+va[0]*scale,cy2-va[1]*scale);ctx.lineTo(cx2+vb[0]*scale,cy2-vb[1]*scale);ctx.stroke();
ctx.strokeStyle='#34d39988';ctx.beginPath();ctx.moveTo(cx2+vc[0]*scale,cy2-vc[1]*scale);ctx.lineTo(cx2+vr[0]*scale,cy2-vr[1]*scale);ctx.stroke();ctx.setLineDash([]);}
let rx=440,ry=45;
ctx.fillStyle='rgba(6,6,12,.9)';ctx.beginPath();ctx.roundRect(rx,ry,300,205,10);ctx.fill();
ctx.fillStyle='#f472b6';ctx.font='700 12px Fira Code';ctx.fillText('Word Vector Arithmetic',rx+10,ry+22);
ctx.fillStyle='#ff6b6b';ctx.font='600 11px Fira Code';ctx.fillText(an.a,rx+10,ry+48);
ctx.fillStyle='#7d7a8c';ctx.fillText(' \u2212 ',rx+60,ry+48);ctx.fillStyle='#38bdf8';ctx.fillText(an.b,rx+80,ry+48);
ctx.fillStyle='#7d7a8c';ctx.fillText(' + ',rx+130,ry+48);ctx.fillStyle='#ffd166';ctx.fillText(an.c,rx+155,ry+48);
ctx.fillStyle='#7d7a8c';ctx.fillText(' = ',rx+210,ry+48);ctx.fillStyle='#34d399';ctx.font='700 11px Fira Code';ctx.fillText(an.result+' \u2713',rx+230,ry+48);
ctx.fillStyle='#e4e2df';ctx.font='400 9px Fira Code';ctx.fillText(an.desc,rx+10,ry+72);
ctx.fillStyle='#ffd166';ctx.font='600 9px Fira Code';ctx.fillText('How Word2Vec learns:',rx+10,ry+100);
ctx.fillStyle='#7d7a8c';ctx.font='400 8px Fira Code';
ctx.fillText('Skip-gram: predict context from word',rx+10,ry+118);
ctx.fillText('"The [cat] sat on" \u2192 predict neighbors',rx+10,ry+134);
ctx.fillText('Similar contexts \u2192 similar vectors',rx+10,ry+150);
ctx.fillText('Relationships become vector directions',rx+10,ry+166);
ctx.fillText('automatically \u2014 no supervision needed!',rx+10,ry+182);
ctx.fillStyle='rgba(6,6,12,.85)';ctx.beginPath();ctx.roundRect(15,282,720,30,8);ctx.fill();
ctx.fillStyle='#7d7a8c';ctx.font='400 9px Fira Code';
ctx.fillText('Each word = dense vector (50-300 dims). Similar meaning = close in space. Relationships = consistent directions.',25,301);}
c.onclick=e=>{let r=c.getBoundingClientRect(),mx=(e.clientX-r.left)*750/r.width,my=(e.clientY-r.top)*320/r.height;
analogies.forEach((a,i)=>{let x=15+i*183;if(mx>=x&&mx<=x+176&&my>=8&&my<=36){selAn=i;draw();}});};
const ctrl=addControls(el);draw()})();

// ===== VAE =====
(function(){const el=$('demo-vae'),[c,ctx]=createCanvas(el,750,340);
addHint(el,'Click a category dot OR hover the latent space. Watch encoder produce \u03bc,\u03c3 and decoder generate from z!');
const G=6,NN=G*G;
const categories=[
  {name:'X',c:'#ff6b6b',z:[-.7,.7],grid:[1,0,0,0,1,0, 0,1,0,1,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,1,0,1,0,0, 1,0,0,0,1,0]},
  {name:'O',c:'#38bdf8',z:[.7,.7],grid:[0,1,1,1,0,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,1,1,1,0,0]},
  {name:'T',c:'#ffd166',z:[-.7,-.7],grid:[1,1,1,1,1,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0]},
  {name:'+',c:'#a78bfa',z:[.7,-.7],grid:[0,0,1,0,0,0, 0,0,1,0,0,0, 1,1,1,1,1,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,0,0,0,0]}
];
let curZ=[0,0],hoverActive=false;
function decodeZ(z1,z2){const out=new Float32Array(NN);let wS=0;
  categories.forEach(cat=>{let d=Math.sqrt((z1-cat.z[0])**2+(z2-cat.z[1])**2)+0.01;let w=1/(d*d*d);wS+=w;
    for(let i=0;i<NN;i++) out[i]+=cat.grid[i]*w;});
  for(let i=0;i<NN;i++) out[i]=clamp(out[i]/wS+Math.sin(z1*3+i)*0.05,0,1);return out;}
function draw(){ctx.clearRect(0,0,750,340);
  const z1=curZ[0],z2=curZ[1];
  // 1. ENCODER
  ctx.fillStyle='#38bdf8';ctx.font='700 10px Fira Code';ctx.fillText('1. Encoder',12,16);
  let closest=categories[0],minD=99;
  categories.forEach(c2=>{let d=Math.sqrt((z1-c2.z[0])**2+(z2-c2.z[1])**2);if(d<minD){minD=d;closest=c2;}});
  ctx.fillStyle='#08081a';ctx.beginPath();ctx.roundRect(12,22,54,54,4);ctx.fill();
  for(let r=0;r<G;r++) for(let ci=0;ci<G;ci++){let v=closest.grid[r*G+ci]*(1-minD*0.3);
    ctx.fillStyle=v>0.3?closest.c:'#111125';ctx.fillRect(14+ci*8,24+r*8,7,7);}
  ctx.fillStyle='#7d7a8c';ctx.font='400 7px Fira Code';ctx.fillText('input x',12,88);
  ctx.fillStyle='#4a475a';ctx.font='16px sans-serif';ctx.fillText('\u2192',70,52);
  // mu,sigma
  ctx.fillStyle='rgba(56,189,248,.08)';ctx.beginPath();ctx.roundRect(88,22,52,28,4);ctx.fill();
  ctx.strokeStyle='#38bdf866';ctx.beginPath();ctx.roundRect(88,22,52,28,4);ctx.stroke();
  ctx.fillStyle='#38bdf8';ctx.font='600 8px Fira Code';ctx.fillText('\u03bc=('+z1.toFixed(1)+','+z2.toFixed(1)+')',91,40);
  ctx.fillStyle='rgba(56,189,248,.08)';ctx.beginPath();ctx.roundRect(88,54,52,28,4);ctx.fill();
  ctx.strokeStyle='#38bdf866';ctx.beginPath();ctx.roundRect(88,54,52,28,4);ctx.stroke();
  ctx.fillStyle='#38bdf8';ctx.font='600 8px Fira Code';ctx.fillText('\u03c3\u00b2=(0.3,0.3)',91,72);

  // 2. LATENT SPACE
  const lx=148,ly=6,lw=210,lh=175;
  ctx.fillStyle='rgba(6,6,12,.92)';ctx.beginPath();ctx.roundRect(lx,ly,lw,lh,8);ctx.fill();
  ctx.fillStyle='#a78bfa';ctx.font='700 9px Fira Code';ctx.fillText('2. Latent Space (z\u2081,z\u2082)',lx+6,ly+14);
  for(let i=-1;i<=1;i++){let gx2=lx+lw/2+i*(lw/4),gy2=ly+lh/2+i*(lh/4);
    ctx.strokeStyle='#1e1e32';ctx.lineWidth=1;
    ctx.beginPath();ctx.moveTo(gx2,ly+20);ctx.lineTo(gx2,ly+lh-4);ctx.stroke();
    ctx.beginPath();ctx.moveTo(lx+4,gy2);ctx.lineTo(lx+lw-4,gy2);ctx.stroke();}
  categories.forEach(cat=>{let cx2=lx+lw/2+cat.z[0]/1.2*(lw/2-12),cy2=ly+lh/2-cat.z[1]/1.2*(lh/2-18);
    let gr=ctx.createRadialGradient(cx2,cy2,0,cx2,cy2,35);gr.addColorStop(0,cat.c+'33');gr.addColorStop(1,cat.c+'00');
    ctx.fillStyle=gr;ctx.beginPath();ctx.arc(cx2,cy2,35,0,TAU);ctx.fill();
    ctx.fillStyle=cat.c;ctx.font='600 9px Fira Code';ctx.textAlign='center';ctx.fillText(cat.name,cx2,cy2+4);ctx.textAlign='left';
    const ms=3;for(let r=0;r<G;r++) for(let ci=0;ci<G;ci++){
      if(cat.grid[r*G+ci]>0.5){ctx.fillStyle=cat.c+'55';ctx.fillRect(cx2-9+ci*ms,cy2+8+r*ms,ms-1,ms-1);}}});
  let zx=lx+lw/2+z1/1.2*(lw/2-12),zy=ly+lh/2-z2/1.2*(lh/2-18);
  ctx.save();ctx.shadowColor='#fff';ctx.shadowBlur=12;ctx.beginPath();ctx.arc(zx,zy,5,0,TAU);ctx.fillStyle='#fff';ctx.fill();ctx.restore();
  ctx.fillStyle='#e4e2df';ctx.font='500 7px Fira Code';ctx.fillText('z=('+z1.toFixed(1)+','+z2.toFixed(1)+')',zx+7,zy-4);

  // Arrow
  ctx.fillStyle='#4a475a';ctx.font='16px sans-serif';ctx.fillText('\u2192',lx+lw+3,ly+lh/2);

  // 3. DECODER + OUTPUT (fits within 750)
  const dx=374;
  ctx.fillStyle='#4ecdc4';ctx.font='700 9px Fira Code';ctx.fillText('3. Decode',dx,16);
  ctx.fillStyle='rgba(78,205,196,.06)';ctx.beginPath();ctx.roundRect(dx,22,50,54,4);ctx.fill();
  ctx.strokeStyle='#4ecdc466';ctx.beginPath();ctx.roundRect(dx,22,50,54,4);ctx.stroke();
  ctx.fillStyle='#7d7a8c';ctx.font='400 7px Fira Code';ctx.fillText('z\u2192x\u0302',dx+8,50);ctx.fillText('net',dx+14,64);
  ctx.fillStyle='#4a475a';ctx.font='16px sans-serif';ctx.fillText('\u2192',dx+55,52);
  // Output grid
  const outX=dx+72,outSz=14;
  ctx.fillStyle='#4ecdc4';ctx.font='700 9px Fira Code';ctx.fillText('Output x\u0302',outX,16);
  const decoded=decodeZ(z1,z2);
  ctx.fillStyle='#08081a';ctx.beginPath();ctx.roundRect(outX-2,20,G*outSz+4,G*outSz+4,4);ctx.fill();
  for(let r=0;r<G;r++) for(let ci=0;ci<G;ci++){let v=decoded[r*G+ci];
    ctx.fillStyle='rgba(78,205,196,'+clamp(v,0.04,1).toFixed(2)+')';ctx.fillRect(outX+ci*outSz,22+r*outSz,outSz-1,outSz-1);}

  // Large comparison: Input vs Output
  const cmpX=outX+G*outSz+14;
  ctx.fillStyle='#ffd166';ctx.font='600 8px Fira Code';ctx.fillText('Compare:',cmpX,16);
  ctx.fillStyle='#38bdf8';ctx.font='400 7px Fira Code';ctx.fillText('In',cmpX,28);
  for(let r=0;r<G;r++) for(let ci=0;ci<G;ci++){let v2=closest.grid[r*G+ci]*(1-minD*0.3);
    ctx.fillStyle=v2>0.3?'#38bdf8':'#0e0e20';ctx.fillRect(cmpX+14+ci*7,20+r*7,6,6);}
  ctx.fillStyle='#4ecdc4';ctx.font='400 7px Fira Code';ctx.fillText('Out',cmpX+62,28);
  for(let r=0;r<G;r++) for(let ci=0;ci<G;ci++){let v2=decoded[r*G+ci];
    ctx.fillStyle='rgba(78,205,196,'+clamp(v2,0.04,1).toFixed(2)+')';ctx.fillRect(cmpX+62+14+ci*7,20+r*7,6,6);}

  // 4. Interpolation strip
  const stripY=ly+lh+12;
  ctx.fillStyle='rgba(6,6,12,.92)';ctx.beginPath();ctx.roundRect(12,stripY,726,68,8);ctx.fill();
  ctx.fillStyle='#ffd166';ctx.font='700 10px Fira Code';ctx.fillText('Key insight: smooth latent space = smooth interpolation!',22,stripY+14);
  const nSteps=12;
  for(let s=0;s<nSteps;s++){let t=s/(nSteps-1);
    let iz1=categories[0].z[0]*(1-t)+categories[1].z[0]*t,iz2=categories[0].z[1]*(1-t)+categories[1].z[1]*t;
    let interp=decodeZ(iz1,iz2);let sx=22+s*42,sy=stripY+22;
    for(let r=0;r<G;r++) for(let ci=0;ci<G;ci++){let v=interp[r*G+ci];
      let col=t<0.5?categories[0].c:categories[1].c;
      ctx.fillStyle=col+(Math.round(clamp(v,0.04,1)*220).toString(16).padStart(2,'0'));
      ctx.fillRect(sx+ci*5,sy+r*5,4,4);}}
  ctx.fillStyle='#ff6b6b';ctx.font='600 8px Fira Code';ctx.fillText('X',22,stripY+60);
  ctx.fillStyle='#7d7a8c';ctx.fillText('\u2190 interpolate in latent space \u2192',200,stripY+60);
  ctx.fillStyle='#38bdf8';ctx.fillText('O',520,stripY+60);
  ctx.fillStyle='#7d7a8c';ctx.font='400 8px Fira Code';ctx.fillText('KL loss \u2192 smooth space',555,stripY+42);
  ctx.fillText('Nearby z = similar x\u0302',555,stripY+58);

  // Bottom
  const exY=stripY+76;
  ctx.fillStyle='rgba(6,6,12,.85)';ctx.beginPath();ctx.roundRect(12,exY,726,46,8);ctx.fill();
  ctx.fillStyle='#a78bfa';ctx.font='600 9px Fira Code';ctx.fillText('Loss = Reconstruction (x\u0302\u2248x) + KL Divergence (keep latent smooth & Gaussian)',22,exY+16);
  ctx.fillStyle='#7d7a8c';ctx.font='400 9px Fira Code';
  ctx.fillText('Reparameterization trick: z=\u03bc+\u03c3\u00b7\u03b5 (\u03b5~N(0,1)) makes sampling differentiable \u2192 can backprop through sampling!',22,exY+34);
}
c.onmousemove=e=>{let r=c.getBoundingClientRect();let mx=(e.clientX-r.left)*750/r.width,my=(e.clientY-r.top)*340/r.height;
  if(mx>=148&&mx<=358&&my>=6&&my<=181){curZ[0]=((mx-148-105)/105*1.2);curZ[1]=-((my-6-87.5)/87.5*1.2);
    curZ[0]=clamp(curZ[0],-1.2,1.2);curZ[1]=clamp(curZ[1],-1.2,1.2);hoverActive=true;draw();}
  else if(hoverActive){hoverActive=false;}};
c.onclick=e=>{let r=c.getBoundingClientRect();let mx=(e.clientX-r.left)*750/r.width,my=(e.clientY-r.top)*340/r.height;
  categories.forEach(cat=>{let cx2=148+210/2+cat.z[0]/1.2*(210/2-12),cy2=6+175/2-cat.z[1]/1.2*(175/2-18);
    if(Math.abs(mx-cx2)<25&&Math.abs(my-cy2)<25){curZ=[cat.z[0],cat.z[1]];draw();}});};
const ctrl=addControls(el);
const rst=document.createElement('button');rst.className='btn';rst.textContent='\u21bb Reset';
rst.onclick=()=>{curZ=[0,0];draw();};ctrl.appendChild(rst);draw()})();


// ===== GAN =====
(function(){const el=$('demo-gan'),[c,ctx]=createCanvas(el,750,320);
addHint(el,'Watch the Generator (pink) learn to match the Real distribution (green). They converge as G fools D!');
let round=0,gMean=80,gStd=100,history=[];
const realMean=350,realStd=50,plotRange=600;
function gauss(x,mu,sig){return Math.exp(-0.5*((x-mu)/sig)**2);}
function step(){round++;
  gMean+=(realMean-gMean)*(0.04+rand(0,0.02));
  gStd+=(realStd-gStd)*(0.035+rand(0,0.015));
  gStd=Math.max(gStd,15);
  let overlap=1-Math.abs(gMean-realMean)/300-Math.abs(gStd-realStd)/150;
  overlap=clamp(overlap,0,1);
  history.push({r:round,gM:gMean,gS:gStd,ov:overlap});
  if(history.length>60)history.shift();draw();}
function draw(){ctx.clearRect(0,0,750,320);
  const pX=15,pY=12,pW=490,pH=175,base=pY+pH-8;
  ctx.fillStyle='rgba(6,6,12,.92)';ctx.beginPath();ctx.roundRect(pX,pY,pW,pH,8);ctx.fill();
  ctx.fillStyle='#ffd166';ctx.font='700 10px Fira Code';ctx.fillText('Generator learns to match Real distribution',pX+8,pY+14);
  // Draw filled distributions with high peaks
  // Real
  ctx.beginPath();ctx.moveTo(pX+8,base);
  for(let px=0;px<pW-16;px++){let x=px/(pW-16)*plotRange;let v=gauss(x,realMean,realStd)*(pH-30);
    ctx.lineTo(pX+8+px,base-v);}
  ctx.lineTo(pX+pW-8,base);ctx.closePath();
  ctx.fillStyle='rgba(52,211,153,0.18)';ctx.fill();
  ctx.strokeStyle='#34d399';ctx.lineWidth=2.5;
  ctx.beginPath();for(let px=0;px<pW-16;px++){let x=px/(pW-16)*plotRange;let v=gauss(x,realMean,realStd)*(pH-30);
    px===0?ctx.moveTo(pX+8+px,base-v):ctx.lineTo(pX+8+px,base-v);}ctx.stroke();
  // Generator
  ctx.beginPath();ctx.moveTo(pX+8,base);
  for(let px=0;px<pW-16;px++){let x=px/(pW-16)*plotRange;let v=gauss(x,gMean,gStd)*(pH-30);
    ctx.lineTo(pX+8+px,base-v);}
  ctx.lineTo(pX+pW-8,base);ctx.closePath();
  ctx.fillStyle='rgba(244,114,182,0.15)';ctx.fill();
  ctx.strokeStyle='#f472b6';ctx.lineWidth=2.5;
  ctx.beginPath();for(let px=0;px<pW-16;px++){let x=px/(pW-16)*plotRange;let v=gauss(x,gMean,gStd)*(pH-30);
    px===0?ctx.moveTo(pX+8+px,base-v):ctx.lineTo(pX+8+px,base-v);}ctx.stroke();
  // Sample dots along baseline
  for(let i=0;i<25;i++){
    let rx=realMean+rand(-1,1)*realStd*1.8;
    ctx.beginPath();ctx.arc(pX+8+rx/(plotRange)*(pW-16),base+6+rand(-2,2),3,0,TAU);ctx.fillStyle='#34d399';ctx.fill();
    let gx=gMean+rand(-1,1)*gStd*1.8;
    ctx.beginPath();ctx.arc(pX+8+gx/(plotRange)*(pW-16),base+14+rand(-2,2),3,0,TAU);ctx.fillStyle='#f472b6';ctx.fill();}
  // Legend inside plot
  ctx.fillStyle='#34d399';ctx.font='600 10px Fira Code';ctx.fillText('\u25cf Real P(x)',pX+pW-148,pY+14);
  ctx.fillStyle='#f472b6';ctx.fillText('\u25cf G(z) generated',pX+pW-148,pY+28);
  // Right panel
  const rx=520,ry=pY;
  ctx.fillStyle='rgba(6,6,12,.92)';ctx.beginPath();ctx.roundRect(rx,ry,220,pH,8);ctx.fill();
  ctx.fillStyle='#ffd166';ctx.font='700 12px Fira Code';ctx.fillText('Round '+round,rx+10,ry+20);
  ctx.fillStyle='#f472b6';ctx.font='600 10px Fira Code';ctx.fillText('\ud83c\udfa8 Generator',rx+10,ry+42);
  ctx.fillStyle='#7d7a8c';ctx.font='400 8px Fira Code';ctx.fillText('Goal: fool Discriminator',rx+10,ry+56);
  ctx.fillText('\u03bc='+gMean.toFixed(0)+' \u03c3='+gStd.toFixed(0)+' (target: \u03bc='+realMean+' \u03c3='+realStd+')',rx+10,ry+70);
  ctx.fillStyle='#38bdf8';ctx.font='600 10px Fira Code';ctx.fillText('\ud83d\udd0d Discriminator',rx+10,ry+92);
  ctx.fillStyle='#7d7a8c';ctx.font='400 8px Fira Code';ctx.fillText('Goal: tell real from fake',rx+10,ry+106);
  let dAcc=round>0?clamp(1-history[history.length-1].ov*0.7,0.3,0.95):0.95;
  ctx.fillText('Accuracy: '+(dAcc*100).toFixed(0)+'%',rx+10,ry+120);
  let conv=round>0?history[history.length-1].ov:0;
  ctx.fillStyle='#111120';ctx.beginPath();ctx.roundRect(rx+10,ry+130,200,16,3);ctx.fill();
  let cGr=ctx.createLinearGradient(rx+10,0,rx+210,0);cGr.addColorStop(0,'#ff6b6b');cGr.addColorStop(0.5,'#ffd166');cGr.addColorStop(1,'#34d399');
  ctx.fillStyle=cGr;ctx.beginPath();ctx.roundRect(rx+10,ry+130,200*conv,16,3);ctx.fill();
  ctx.fillStyle='#e4e2df';ctx.font='bold 9px Fira Code';ctx.fillText('Convergence: '+(conv*100).toFixed(0)+'%',rx+14,ry+143);
  // Bottom history
  const by=pY+pH+10;
  ctx.fillStyle='rgba(6,6,12,.92)';ctx.beginPath();ctx.roundRect(15,by,720,118,8);ctx.fill();
  ctx.fillStyle='#ffd166';ctx.font='600 9px Fira Code';ctx.fillText('Training History:',25,by+14);
  if(history.length>1){ctx.strokeStyle='#34d399';ctx.lineWidth=2;ctx.beginPath();
    history.forEach((h,i)=>{let hx=25+i*(690/60),hy=by+90-h.ov*65;i===0?ctx.moveTo(hx,hy):ctx.lineTo(hx,hy);});ctx.stroke();
    ctx.fillStyle='#34d399';ctx.font='400 7px Fira Code';ctx.fillText('overlap \u2191',690,by+14);}
  ctx.fillStyle='#7d7a8c';ctx.font='400 8px Fira Code';
  ctx.fillText('G and D compete: G improves fakes \u2192 D must adapt \u2192 G improves more \u2192 converges when D can\'t tell them apart!',25,by+110);}
const ctrl=addControls(el);
const sb=document.createElement('button');sb.className='btn';sb.textContent='\u25b6 Train';sb.onclick=step;
let tmr=null;const ab=document.createElement('button');ab.className='btn';ab.textContent='\u23e9 Auto';
ab.onclick=()=>{if(tmr){clearInterval(tmr);tmr=null;ab.classList.remove('active');}else{tmr=setInterval(step,120);ab.classList.add('active');}};
const rst=document.createElement('button');rst.className='btn';rst.textContent='\u21bb Reset';
rst.onclick=()=>{round=0;gMean=80;gStd=100;history=[];if(tmr){clearInterval(tmr);tmr=null;ab.classList.remove('active');}draw();};
ctrl.appendChild(sb);ctrl.appendChild(ab);ctrl.appendChild(rst);draw()})();


// ===== SEQ2SEQ + ATTENTION =====
(function(){const el=$('demo-attn'),[c,ctx]=createCanvas(el,750,300);
addHint(el,'Click any French word below to see which English words it attends to. Brighter/thicker lines = higher attention.');
const src=['The','cat','sat','on','the','mat'];
const tgt=['Le','chat','\u00e9tait','assis','sur','le','tapis'];
const attnM=[[.8,.05,.02,.02,.08,.03],[.05,.75,.05,.03,.02,.1],[.02,.1,.6,.15,.03,.1],
[.03,.05,.15,.65,.05,.07],[.05,.02,.03,.1,.7,.1],[.7,.03,.02,.02,.15,.08],[.02,.08,.05,.05,.1,.7]];
let selT=1;
function draw(){ctx.clearRect(0,0,750,300);
let srcX=50,srcY=28,tgtY=195,bw=98,tBw=95;
ctx.fillStyle='#38bdf8';ctx.font='600 10px Fira Code';ctx.fillText('Source (English):',15,srcY-5);
src.forEach((w,i)=>{let x=srcX+i*108;let attn=attnM[selT][i];
ctx.fillStyle='rgba(56,189,248,'+(0.05+attn*0.4).toFixed(2)+')';ctx.beginPath();ctx.roundRect(x,srcY,bw,32,6);ctx.fill();
ctx.strokeStyle='rgba(56,189,248,'+(0.2+attn*0.8).toFixed(2)+')';ctx.lineWidth=1+attn*3;ctx.beginPath();ctx.roundRect(x,srcY,bw,32,6);ctx.stroke();
ctx.fillStyle='#e4e2df';ctx.font='500 11px Fira Code';ctx.textAlign='center';ctx.fillText(w,x+bw/2,srcY+20);
ctx.fillStyle='#ffd166';ctx.font='500 8px Fira Code';ctx.fillText((attn*100|0)+'%',x+bw/2,srcY+44);ctx.textAlign='left';});
// Attention connections (draw BEFORE target boxes)
src.forEach((w,i)=>{let attn=attnM[selT][i];if(attn<.02)return;
  let sx=srcX+i*108+bw/2,sy=srcY+32;
  let tx=15+selT*102+tBw/2,ty=tgtY;
  ctx.strokeStyle='rgba(255,209,102,'+attn.toFixed(2)+')';ctx.lineWidth=attn*8;
  ctx.beginPath();ctx.moveTo(sx,sy+12);ctx.quadraticCurveTo((sx+tx)/2,sy+60,tx,ty);ctx.stroke();});
ctx.fillStyle='#4ecdc4';ctx.font='600 10px Fira Code';ctx.fillText('Target (French) \u2014 click a word:',15,tgtY-8);
tgt.forEach((w,i)=>{let x=15+i*102;let isSel=i===selT;
ctx.fillStyle=isSel?'rgba(78,205,196,.18)':'rgba(78,205,196,.04)';ctx.beginPath();ctx.roundRect(x,tgtY,tBw,32,6);ctx.fill();
ctx.strokeStyle=isSel?'#4ecdc4':'#4ecdc433';ctx.lineWidth=isSel?2.5:1;ctx.beginPath();ctx.roundRect(x,tgtY,tBw,32,6);ctx.stroke();
ctx.fillStyle=isSel?'#e4e2df':'#7d7a8c';ctx.font=(isSel?'700':'400')+' 11px Fira Code';ctx.textAlign='center';ctx.fillText(w,x+tBw/2,tgtY+20);ctx.textAlign='left';});
ctx.fillStyle='rgba(6,6,12,.85)';ctx.beginPath();ctx.roundRect(15,246,720,48,8);ctx.fill();
ctx.fillStyle='#ffd166';ctx.font='600 9px Fira Code';ctx.fillText('Attention: "'+tgt[selT]+'" focuses on: '+src.map((w,i)=>attnM[selT][i]>.1?w+' ('+Math.round(attnM[selT][i]*100)+'%)':'').filter(Boolean).join(', '),25,264);
ctx.fillStyle='#7d7a8c';ctx.font='400 9px Fira Code';ctx.fillText('Without attention: entire input crammed into ONE vector. With attention: decoder looks back at relevant words each step!',25,284);}
c.onclick=e=>{let r=c.getBoundingClientRect(),my=(e.clientY-r.top)*300/r.height,mx=(e.clientX-r.left)*750/r.width;
if(my>=195-10&&my<=195+42){tgt.forEach((w,i)=>{let x=15+i*102;if(mx>=x&&mx<=x+95){selT=i;draw();}});}};
const ctrl=addControls(el);
// Add clickable target word buttons for easier interaction
tgt.forEach((w,i)=>{const b=document.createElement('button');b.className='btn';b.textContent=w;b.style.cssText='font-size:10px;padding:2px 8px';
  b.onclick=()=>{selT=i;draw();};ctrl.appendChild(b);});
draw()})();

// ===== RESNET =====
(function(){const el=$('demo-resnet'),[c,ctx]=createCanvas(el,750,300);
addHint(el,'Toggle skip connections on/off. Watch gradient dots flow (or vanish!) through the network.');
let skipOn=true,depth=8,animT=0,animId=null;
function startGradAnim(){animT=0;if(animId)cancelAnimationFrame(animId);
  (function tick(){animT+=0.008;draw();if(animT<2)animId=requestAnimationFrame(tick);else{animId=null;draw();}})();}
function draw(){ctx.clearRect(0,0,750,300);
let bx=50,by=45,bw=75,bh=45,gap=5;
for(let i=0;i<depth;i++){let x=bx+i*(bw+gap),y=by;
let grad=skipOn?1-i*0.05:Math.max(1-i*0.25,0.02);
ctx.fillStyle='rgba(167,139,250,'+(grad*.15).toFixed(2)+')';ctx.beginPath();ctx.roundRect(x,y,bw,bh,6);ctx.fill();
ctx.strokeStyle='rgba(167,139,250,'+(grad*.8+.2).toFixed(2)+')';ctx.lineWidth=1.5;ctx.beginPath();ctx.roundRect(x,y,bw,bh,6);ctx.stroke();
ctx.fillStyle='rgba(228,226,223,'+grad.toFixed(2)+')';ctx.font='600 9px Fira Code';ctx.textAlign='center';ctx.fillText('Block '+(i+1),x+bw/2,y+18);
ctx.fillStyle='rgba(125,122,140,'+grad.toFixed(2)+')';ctx.font='400 7px Fira Code';ctx.fillText('F(x)',x+bw/2,y+32);
// Gradient bar
ctx.fillStyle='#111120';ctx.fillRect(x+5,y+bh+5,bw-10,8);
ctx.fillStyle=grad>.3?'#34d399':'#ff6b6b';ctx.fillRect(x+5,y+bh+5,(bw-10)*grad,8);
ctx.fillStyle='#7d7a8c';ctx.font='400 6px Fira Code';ctx.fillText('grad: '+(grad*100|0)+'%',x+bw/2,y+bh+20);ctx.textAlign='left';
// Skip connections
if(skipOn&&i%2===0&&i+2<=depth){let sx=x+bw/2,ex=Math.min(x+(bw+gap)*2+bw/2,bx+(depth-1)*(bw+gap)+bw/2);
ctx.strokeStyle='#ffd16688';ctx.lineWidth=2;ctx.setLineDash([5,3]);ctx.beginPath();
ctx.moveTo(sx,y);ctx.quadraticCurveTo((sx+ex)/2,y-28,ex,y);ctx.stroke();ctx.setLineDash([]);
ctx.fillStyle='#ffd166';ctx.font='bold 12px Fira Code';ctx.textAlign='center';ctx.fillText('+',ex,y-5);ctx.textAlign='left';}
if(i<depth-1){ctx.fillStyle='#4a475a';ctx.font='10px sans-serif';ctx.fillText('\u2192',x+bw+1,y+bh/2+4);}}
// Animated gradient dots flowing backward (right to left)
if(animT>0){
  let nDots=skipOn?18:10;
  for(let d=0;d<nDots;d++){
    // Each dot has a phase offset
    let phase=(animT-d*0.06)%1.0;
    if(phase<0||phase>1)continue;
    let totalW=depth*(bw+gap);
    // Gradient flows RIGHT TO LEFT (backprop)
    let dotX=bx+totalW-(phase*totalW);
    // Which block is this dot in?
    let blockIdx=Math.floor((bx+totalW-dotX)/(bw+gap));
    blockIdx=clamp(blockIdx,0,depth-1);
    let grad=skipOn?1-blockIdx*0.05:Math.max(1-blockIdx*0.25,0.02);
    let alpha=grad*0.9;
    if(alpha<0.05)continue;
    // Main path dot
    let dotY=by+bh/2;
    ctx.save();ctx.shadowColor=skipOn?'#34d399':'#ff6b6b';ctx.shadowBlur=8;
    ctx.beginPath();ctx.arc(dotX,dotY,3+grad*2,0,TAU);
    ctx.fillStyle=skipOn?'rgba(52,211,153,'+alpha.toFixed(2)+')':'rgba(255,107,107,'+alpha.toFixed(2)+')';
    ctx.fill();ctx.restore();
    // Skip path dots (some dots travel along skip arcs)
    if(skipOn&&d%3===0){
      let skipPhase=((animT-d*0.06)*0.7)%1;
      if(skipPhase>0&&skipPhase<1){
        let si=Math.floor(d/3)%4*2; // skip from block si to si+2
        if(si+2<=depth){
          let sx2=bx+si*(bw+gap)+bw/2,ex2=Math.min(bx+(si+2)*(bw+gap)+bw/2,bx+(depth-1)*(bw+gap)+bw/2);
          let t=skipPhase;
          let spx=(1-t)*ex2+t*sx2; // right to left
          let spy=by-28+28*4*(t-0.5)*(t-0.5); // arc
          ctx.save();ctx.shadowColor='#ffd166';ctx.shadowBlur=6;
          ctx.beginPath();ctx.arc(spx,spy,3,0,TAU);ctx.fillStyle='rgba(255,209,102,'+(.7).toFixed(2)+')';ctx.fill();ctx.restore();
        }
      }
    }
  }
}
// Info box
let fy=132;ctx.fillStyle='rgba(6,6,12,.88)';ctx.beginPath();ctx.roundRect(15,fy,720,55,10);ctx.fill();
ctx.fillStyle=skipOn?'#ffd166':'#ff6b6b';ctx.font='700 12px Fira Code';
ctx.fillText(skipOn?'output = F(x) + x  \u2190 skip connection':'output = F(x)  \u2190 no skip (plain)',25,fy+20);
ctx.fillStyle='#e4e2df';ctx.font='400 9px Fira Code';
ctx.fillText(skipOn?'Gradient flows through BOTH F(x) path AND identity shortcut. Even if F(x) vanishes, +x path survives!':
'Gradient must pass through ALL layers sequentially. After many layers \u2192 vanishing gradient problem.',25,fy+38);
ctx.fillStyle='#7d7a8c';ctx.fillText(skipOn?'ResNet-152 won ImageNet 2015. Skip connections allow 100+ layers!':'Without skips, networks >20 layers become untrainable.',25,fy+52);
// Gradient comparison
ctx.fillStyle='rgba(6,6,12,.85)';ctx.beginPath();ctx.roundRect(15,200,720,92,10);ctx.fill();
ctx.fillStyle='#a78bfa';ctx.font='600 10px Fira Code';ctx.fillText('Gradient strength at each layer (backprop):',25,218);
['Layer 1','Layer 4','Layer 8'].forEach((l,li)=>{let y2=228+li*20;
ctx.fillStyle='#7d7a8c';ctx.font='400 9px Fira Code';ctx.fillText(l,25,y2+10);
ctx.fillStyle='#111120';ctx.fillRect(100,y2,200,14);ctx.fillRect(410,y2,200,14);
let gs=[1,.8,.6],gn=[1,.25,.02];
ctx.fillStyle='#34d399';ctx.beginPath();ctx.roundRect(100,y2,200*gs[li],14,2);ctx.fill();
ctx.fillStyle='#ff6b6b';ctx.beginPath();ctx.roundRect(410,y2,200*gn[li],14,2);ctx.fill();});
ctx.fillStyle='#34d399';ctx.font='600 8px Fira Code';ctx.fillText('With Skip (ResNet)',100,226);
ctx.fillStyle='#ff6b6b';ctx.fillText('Without Skip (Plain)',410,226);}
const ctrl=addControls(el);
const tog=document.createElement('button');tog.className='btn active';tog.textContent='\u2705 Skip ON';
tog.onclick=()=>{skipOn=!skipOn;tog.textContent=skipOn?'\u2705 Skip ON':'\u274c Skip OFF';tog.classList.toggle('active');startGradAnim();};
const ga=document.createElement('button');ga.className='btn';ga.textContent='\u26a1 Flow Gradient';ga.onclick=startGradAnim;
ctrl.appendChild(tog);ctrl.appendChild(ga);draw()})();

// ===== BATCH NORMALIZATION =====
(function(){const el=$('demo-bn'),[c,ctx]=createCanvas(el,750,310);
addHint(el,'Toggle BatchNorm on/off. Watch layer distributions go from tidy to chaotic! All layers share the SAME axis scale.');
let bnOn=true;
// FIXED raw activations so toggling BN shows the same data differently
let rawActs=[];
function generateRaw(){rawActs=[];for(let l=0;l<5;l++){let a=[];
  for(let i=0;i<200;i++){
    // Deeper layers have MUCH wider, shifted distributions
    let base=Math.sin(i*.3+l*2)*0.8;
    let noise=rand(-1,1)*(0.4+l*0.55); // spread grows with depth
    let shift=l*0.8; // mean drifts with depth
    a.push(base+noise+shift);
  }rawActs.push(a);}}
generateRaw();

function getActs(layer,bn){
  let acts=[...rawActs[layer]];
  if(bn){let mean=acts.reduce((a,b)=>a+b)/acts.length;
    let std=Math.sqrt(acts.reduce((a,b)=>a+(b-mean)**2,0)/acts.length)||1;
    acts=acts.map(v=>(v-mean)/std*0.5);} // normalize to tight range
  return acts;}

function draw(){ctx.clearRect(0,0,750,310);
  let nLayers=5,lw=140,lh=128,ox=8;
  // GLOBAL fixed range so all histograms share the same x-axis
  const globalMin=-5,globalMax=7; // fixed axis
  const globalRange=globalMax-globalMin;
  const nBins=28;

  for(let l=0;l<nLayers;l++){let x=ox+l*(lw+5),y=10;
    let acts=getActs(l,bnOn);
    // Bin into fixed global range
    let bins=Array(nBins).fill(0);
    acts.forEach(v=>{let bi=Math.floor((v-globalMin)/globalRange*nBins);
      if(bi>=0&&bi<nBins)bins[bi]++;});
    // Use a GLOBAL max bin count for consistent bar heights across layers
    let maxBin=Math.max(...bins,1);
    // Panel
    ctx.fillStyle='rgba(6,6,12,.88)';ctx.beginPath();ctx.roundRect(x,y,lw,lh,6);ctx.fill();
    // Color based on how well-behaved
    let mean=acts.reduce((a,b)=>a+b)/acts.length;
    let std=Math.sqrt(acts.reduce((a,v)=>a+(v-mean)**2,0)/acts.length);
    let isGood=std<1.5;
    ctx.strokeStyle=isGood?'#34d39966':'#ff6b6b66';ctx.lineWidth=2;
    ctx.beginPath();ctx.roundRect(x,y,lw,lh,6);ctx.stroke();
    // Histogram bars
    let bw2=(lw-8)/nBins;
    bins.forEach((b,bi)=>{if(b===0)return;
      let bx2=x+4+bi*bw2, bh2=(b/maxBin)*(lh-30);
      let intensity=clamp(b/maxBin,0.2,1);
      if(isGood){
        ctx.fillStyle='rgba(52,211,153,'+intensity.toFixed(2)+')';
      } else {
        ctx.fillStyle='rgba(255,107,107,'+intensity.toFixed(2)+')';
      }
      ctx.fillRect(bx2,y+lh-4-bh2,bw2-0.5,bh2);});
    // Mean line
    let meanX=x+4+(mean-globalMin)/globalRange*(lw-8);
    if(meanX>x+4&&meanX<x+lw-4){
      ctx.strokeStyle='#ffd166';ctx.lineWidth=2;ctx.setLineDash([3,2]);
      ctx.beginPath();ctx.moveTo(meanX,y+14);ctx.lineTo(meanX,y+lh-4);ctx.stroke();ctx.setLineDash([]);}
    // +/- 1 std shading
    let stdL=x+4+((mean-std)-globalMin)/globalRange*(lw-8);
    let stdR=x+4+((mean+std)-globalMin)/globalRange*(lw-8);
    stdL=clamp(stdL,x+4,x+lw-4);stdR=clamp(stdR,x+4,x+lw-4);
    ctx.fillStyle='rgba(255,209,102,0.06)';ctx.fillRect(stdL,y+14,stdR-stdL,lh-18);
    // Labels
    ctx.fillStyle=isGood?'#34d399':'#ff6b6b';ctx.font='700 10px Fira Code';ctx.textAlign='center';
    ctx.fillText('Layer '+(l+1),x+lw/2,y+13);
    ctx.fillStyle='#e4e2df';ctx.font='500 8px Fira Code';
    ctx.fillText('\u03bc='+mean.toFixed(1)+' \u03c3='+std.toFixed(1),x+lw/2,y+lh+12);
    if(!bnOn&&l>=3){ctx.fillStyle='#ff6b6b';ctx.font='bold 9px Fira Code';ctx.fillText('\u26a0 EXPLODING!',x+lw/2,y+lh+24);}
    if(bnOn){ctx.fillStyle='#34d39988';ctx.font='400 7px Fira Code';ctx.fillText('normalized',x+lw/2,y+lh+24);}
    ctx.textAlign='left';}
  // Info
  let iy=170;ctx.fillStyle='rgba(6,6,12,.9)';ctx.beginPath();ctx.roundRect(8,iy,734,130,10);ctx.fill();
  ctx.fillStyle=bnOn?'#34d399':'#ff6b6b';ctx.font='700 14px Fira Code';
  ctx.fillText(bnOn?'\u2705 BatchNorm ON':'\u274c BatchNorm OFF',20,iy+22);
  if(bnOn){
    ctx.fillStyle='#e4e2df';ctx.font='400 9px Fira Code';
    ctx.fillText('All 5 layers: tight, centered distributions. Every layer sees well-behaved inputs (\u03bc\u22480, \u03c3\u22480.5).',20,iy+42);
    ctx.fillText('Result: stable gradients, fast convergence, can use higher learning rates safely.',20,iy+58);
    ctx.fillStyle='#ffd166';ctx.font='500 9px Fira Code';
    ctx.fillText('x\u0302 = (x\u2212\u03bc_batch)/\u221a(\u03c3\u00b2+\u03b5)  then  y = \u03b3\u00b7x\u0302 + \u03b2  (\u03b3,\u03b2 learnable per layer)',20,iy+78);
    ctx.fillStyle='#7d7a8c';ctx.font='400 8px Fira Code';
    ctx.fillText('Yellow dashed = mean, shaded = \u00b11\u03c3. All histograms are tall & narrow = concentrated around 0.',20,iy+96);
  } else {
    ctx.fillStyle='#e4e2df';ctx.font='400 9px Fira Code';
    ctx.fillText('Without BN: deeper layers drift (mean shifts) and explode (std grows). Compare Layer 1 vs Layer 5!',20,iy+42);
    ctx.fillStyle='#ff6b6b';ctx.font='600 9px Fira Code';
    ctx.fillText('Layer 1: \u03c3\u22481 (narrow, centered)    vs    Layer 5: \u03c3\u22483+ (wide, shifted) \u2192 UNSTABLE training!',20,iy+58);
    ctx.fillStyle='#e4e2df';ctx.font='400 9px Fira Code';
    ctx.fillText('This is "internal covariate shift": each layer sees wildly different input distributions every update.',20,iy+78);
    ctx.fillStyle='#7d7a8c';ctx.font='400 8px Fira Code';
    ctx.fillText('Histograms use the SAME x-axis range \u2192 you can see Layer 5 spread much wider than Layer 1.',20,iy+96);
  }
  ctx.fillStyle='#7d7a8c';ctx.font='400 8px Fira Code';
  ctx.fillText('Used in nearly every modern deep network. Adapted as LayerNorm (across features) in Transformers.',20,iy+116);}
const ctrl=addControls(el);
const tog=document.createElement('button');tog.className='btn active';tog.textContent='\u2705 BN ON';
tog.onclick=()=>{bnOn=!bnOn;tog.textContent=bnOn?'\u2705 BN ON':'\u274c BN OFF';tog.classList.toggle('active');draw();};
const rs2=document.createElement('button');rs2.className='btn';rs2.textContent='\ud83c\udfb2 Resample';rs2.onclick=()=>{generateRaw();draw();};
ctrl.appendChild(tog);ctrl.appendChild(rs2);draw()})();

</script></body></html>
