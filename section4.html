<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Section IV — The Golden Age of Statistical Learning · How AI Works</title>
<link rel="stylesheet" href="styles.css">
</head><body>
<div class="progress-bar" style="background:linear-gradient(90deg,var(--a2),var(--a6))"></div>
<button class="back-top" onclick="window.scrollTo({top:0,behavior:'smooth'})">↑</button>
<nav class="topnav"><a href="index.html" class="logo">How AI Works</a><div class="nav-links"><a href="section1.html">I</a><a href="section2.html">II</a><a href="section3.html">III</a><a href="section4.html" class="active">IV</a><a href="section5.html">V</a><a href="section6.html">VI</a><a href="section7.html">VII</a><a href="section8.html">VIII</a></div></nav>
<div class="section-hero"><div class="era-label" style="color:var(--a2)">Section IV · 1990s–2001</div>
<h1>The Golden Age of Statistical Learning</h1><p>SVM, LSTM, Random Forest — the classics that powered ML before deep learning took over.</p>
<div class="nav-arrows"><a href="section3.html">&larr; Section III</a><a href="section5.html">Section V &rarr;</a></div></div>
<div class="models-container">

<!-- ======= CNN / LeNet ======= -->
<div class="model-card" id="model-cnn"><div class="mc-head"><span class="mc-year" style="color:var(--a2)">1998</span><div class="mc-info">
<h3>CNN / LeNet <a href="http://yann.lecun.com/exdb/lenet/" target="_blank" class="paper-link">Paper</a></h3>
<p>LeCun's convolutional neural network for handwritten digit recognition. Convolution filters slide over the image to extract features, then pooling shrinks them.</p>
<div class="model-lineage">Adds <a href="section3.html#model-backprop">Backpropagation</a> training to <a href="section3.html#model-neocognitron">Neocognitron</a>'s hierarchical design; directly leads to <a href="section6.html#model-alexnet">AlexNet</a> and <a href="section6.html#model-resnet">ResNet</a>.</div>
</div></div>
<div class="mc-formula" style="color:var(--a2)">Input → [Conv → ReLU → Pool] × N → Flatten → Dense → Output class</div>
<div class="mc-demo" id="demo-cnn"></div></div>

<!-- ======= LSTM ======= -->
<div class="model-card" id="model-lstm"><div class="mc-head"><span class="mc-year" style="color:var(--a2)">1997</span><div class="mc-info">
<h3>LSTM (Long Short-Term Memory) <a href="https://doi.org/10.1162/neco.1997.9.8.1735" target="_blank" class="paper-link">Paper</a></h3>
<p>Hochreiter & Schmidhuber's solution to vanishing gradients. Three gates (forget, input, output) control what to remember, add, and output from the cell state.</p>
<div class="model-lineage">Solves <a href="section3.html#model-rnn">RNN</a>'s vanishing gradient problem with gated memory; enables <a href="section6.html#model-seq2seq">Seq2Seq</a> translation and <a href="section7.html#model-elmo">ELMo</a> embeddings.</div>
</div></div>
<div class="mc-formula" style="color:var(--a2)">fₜ = σ(forget) &nbsp; iₜ = σ(input) &nbsp; oₜ = σ(output) &nbsp; cₜ = fₜ⊙cₜ₋₁ + iₜ⊙tanh(…)</div>
<div class="mc-demo" id="demo-lstm"></div></div>

<!-- ======= SVM ======= -->
<div class="model-card" id="model-svm"><div class="mc-head"><span class="mc-year" style="color:var(--a2)">1995</span><div class="mc-info">
<h3>SVM (Support Vector Machine) <a href="https://doi.org/10.1007/BF00994018" target="_blank" class="paper-link">Paper</a></h3>
<p>Vapnik's maximum-margin classifier — find the hyperplane that separates classes with the widest possible margin. Support vectors define the boundary.</p>
<div class="model-lineage">Extends <a href="section2.html#model-knn">k-NN</a>'s distance-based idea with kernel tricks for non-linear boundaries; dominated ML before <a href="section6.html#model-alexnet">AlexNet</a> proved deep learning superior.</div>
</div></div>
<div class="mc-formula" style="color:var(--a2)">maximize margin = 2/||w|| &nbsp; subject to yᵢ(w·xᵢ + b) ≥ 1</div>
<div class="mc-demo" id="demo-svm"></div></div>

<!-- ======= GMM + EM ======= -->
<div class="model-card" id="model-gmm"><div class="mc-head"><span class="mc-year" style="color:var(--a2)">1977</span><div class="mc-info">
<h3>GMM + EM Algorithm <a href="https://doi.org/10.1111/j.2517-6161.1977.tb01600.x" target="_blank" class="paper-link">Paper</a></h3>
<p>Fit a mixture of Gaussians to data using Expectation-Maximization. E-step: soft cluster assignment. M-step: update parameters. Iterate until convergence.</p>
<div class="model-lineage">Applies <a href="section1.html#model-bayes">Bayes' Theorem</a> to unsupervised clustering with latent variables; EM's iterative approach later inspires <a href="section6.html#model-vae">VAE</a>'s variational inference.</div>
</div></div>
<div class="mc-formula" style="color:var(--a2)">E: P(k|xᵢ) = πₖN(xᵢ|μₖ,σₖ) / Σⱼ πⱼN(xᵢ|μⱼ,σⱼ) &nbsp; M: update μ,σ,π</div>
<div class="mc-demo" id="demo-gmm"></div></div>

<!-- ======= RANDOM FOREST ======= -->
<div class="model-card" id="model-randomforest"><div class="mc-head"><span class="mc-year" style="color:var(--a2)">2001</span><div class="mc-info">
<h3>Random Forest <a href="https://doi.org/10.1023/A:1010933404324" target="_blank" class="paper-link">Paper</a></h3>
<p>Breiman's ensemble of decision trees — each tree trained on a random subset of data and features. Final prediction by majority vote.</p>
<div class="model-lineage">Ensembles many <a href="section3.html#model-dtree">Decision Trees</a> via bagging to reduce overfitting; the ensemble idea is refined by <a href="section5.html#model-gbdt">GBDT</a> and <a href="section7.html#model-xgboost">XGBoost</a> using boosting instead.</div>
</div></div>
<div class="mc-formula" style="color:var(--a2)">prediction = mode(tree₁(x), tree₂(x), ..., treeₙ(x)) — majority vote of random trees</div>
<div class="mc-demo" id="demo-rf"></div></div>

<!-- ======= ADABOOST ======= -->
<div class="model-card" id="model-adaboost"><div class="mc-head"><span class="mc-year" style="color:var(--a2)">1997</span><div class="mc-info">
<h3>AdaBoost <a href="https://doi.org/10.1006/jcss.1997.1504" target="_blank" class="paper-link">Paper</a></h3>
<p>Freund & Schapire's adaptive boosting — train weak classifiers sequentially, each focusing on mistakes of previous ones by upweighting misclassified samples.</p>
<div class="model-lineage">Introduces sequential boosting of <a href="section3.html#model-dtree">Decision Tree</a> stumps; directly inspires <a href="section5.html#model-gbdt">GBDT</a> (gradient-based boosting) and <a href="section7.html#model-xgboost">XGBoost</a>.</div>
</div></div>
<div class="mc-formula" style="color:var(--a2)">H(x) = sign(Σ αₜhₜ(x)) &nbsp; where αₜ = ½ ln((1-εₜ)/εₜ) — weight by accuracy</div>
<div class="mc-demo" id="demo-ada"></div></div>

</div>
<footer><a href="section3.html">&larr; Section III</a> &middot; <a href="section5.html">Section V: Eve of Deep Learning &rarr;</a></footer>
<script src="shared.js"></script>
<script>
// ============================================================
//  CNN / LeNet  —  28x28 Handwritten Digit Recognition
// ============================================================
(function(){
const el=$('demo-cnn'),[c,ctx]=createCanvas(el,750,340);
addHint(el,'Draw a digit (0-9) on the 28\u00d728 canvas. Watch convolution filters detect edges, pooling shrinks maps, then see classification scores.');

const G=28, CS=7;
let grid=Array.from({length:G},()=>new Float32Array(G));
let drawing=false, lastPt=null;
let scanRow=-1, animId=null;

const filters=[
  {n:'Horiz. Edge',k:[[1,1,1],[0,0,0],[-1,-1,-1]],c:'#ff6b6b'},
  {n:'Vert. Edge', k:[[1,0,-1],[1,0,-1],[1,0,-1]], c:'#38bdf8'},
  {n:'Diagonal',   k:[[0,-1,1],[1,0,-1],[-1,1,0]], c:'#a78bfa'}
];

function conv2d(src,k){
  const kh=k.length,kw=k[0].length,oh=src.length-kh+1,ow=src[0].length-kw+1;
  const out=Array.from({length:oh},()=>new Float32Array(ow));
  for(let r=0;r<oh;r++) for(let c2=0;c2<ow;c2++){
    let s=0; for(let kr=0;kr<kh;kr++) for(let kc=0;kc<kw;kc++) s+=src[r+kr][c2+kc]*k[kr][kc];
    out[r][c2]=Math.max(0,s);
  } return out;
}
function maxPool(src,s){
  const oh=Math.floor(src.length/s),ow=Math.floor((src[0]||[]).length/s);
  const out=Array.from({length:oh},()=>new Float32Array(ow));
  for(let r=0;r<oh;r++) for(let c2=0;c2<ow;c2++){
    let mx=0; for(let pr=0;pr<s;pr++) for(let pc=0;pc<s;pc++)
      mx=Math.max(mx,(src[r*s+pr]||[])[c2*s+pc]||0);
    out[r][c2]=mx;
  } return out;
}
function energy(fm){ let s=0; for(const row of fm) for(const v of row) s+=v; return s; }

/* --- Feature extraction: 4x7 block densities + horizontal crossings --- */
const BX=4, BY=7;  // 4 columns x 7 rows of blocks
function extractFeatures(g){
  const feat=[];
  // Block densities (28 features)
  const bw=G/BX, bh=G/BY;
  for(let br=0;br<BY;br++) for(let bc=0;bc<BX;bc++){
    let s=0,cnt=0;
    for(let r=Math.floor(br*bh);r<Math.floor((br+1)*bh);r++)
      for(let c2=Math.floor(bc*bw);c2<Math.floor((bc+1)*bw);c2++){ s+=g[r][c2]; cnt++; }
    feat.push(s/(cnt||1));
  }
  // Horizontal crossing count at 7 heights (7 features)
  for(let ri=0;ri<7;ri++){
    const r=Math.floor((ri+.5)/7*G);
    let crossings=0, prev=0;
    for(let c2=0;c2<G;c2++){const cur=g[r][c2]>.3?1:0;if(cur!==prev&&c2>0)crossings++;prev=cur;}
    feat.push(crossings/6); // normalize
  }
  // Vertical crossing count at 4 widths (4 features)
  for(let ci=0;ci<4;ci++){
    const c2=Math.floor((ci+.5)/4*G);
    let crossings=0, prev=0;
    for(let r=0;r<G;r++){const cur=g[r][c2]>.3?1:0;if(cur!==prev&&r>0)crossings++;prev=cur;}
    feat.push(crossings/6);
  }
  // Global features: density, symmetry, top/bottom ratio (3 features)
  let filled=0,topH=0,botH=0,leftH=0,rightH=0;
  for(let r=0;r<G;r++) for(let c2=0;c2<G;c2++){
    const v=g[r][c2]; filled+=v;
    if(r<G/2)topH+=v;else botH+=v;
    if(c2<G/2)leftH+=v;else rightH+=v;
  }
  feat.push(filled/(G*G));
  feat.push(1-Math.abs(leftH-rightH)/(leftH+rightH+.01));
  feat.push(topH/(topH+botH+.01));
  return feat;
}

function featDist(a,b){
  let s=0; for(let i=0;i<a.length;i++) s+=(a[i]-b[i])**2; return Math.sqrt(s);
}

/* --- Template-based classification (nearest neighbor) --- */
let templates=[]; // [{digit, feat}]

function buildTemplates(){
  templates=[];
  // We generate each digit preset into a temp grid, extract features, store as template
  const presetDefs=[
    {d:0,f:()=>{tmpClear();tmpCircle(14,14,8,10)}},
    {d:1,f:()=>{tmpClear();tmpLine(12,5,14,5);tmpLine(14,4,14,24);tmpLine(10,24,18,24)}},
    {d:2,f:()=>{tmpClear();for(let a=Math.PI;a>=-0.1;a-=.08)tmpStamp(Math.round(14+7*Math.cos(a)),Math.round(9+6*Math.sin(a)));tmpLine(21,9,8,23);tmpLine(8,23,22,23)}},
    {d:3,f:()=>{tmpClear();for(let a=-Math.PI*.6;a<Math.PI*.6;a+=.08){tmpStamp(Math.round(13+7*Math.cos(a)),Math.round(8+6*Math.sin(a)));tmpStamp(Math.round(13+7*Math.cos(a)),Math.round(19+6*Math.sin(a)));}}},
    {d:4,f:()=>{tmpClear();tmpLine(6,4,6,15);tmpLine(6,15,20,15);tmpLine(16,4,16,24)}},
    {d:5,f:()=>{tmpClear();tmpLine(19,4,8,4);tmpLine(8,4,8,13);tmpLine(8,13,17,13);for(let a=-Math.PI*.5;a<Math.PI*.7;a+=.08)tmpStamp(Math.round(15+6*Math.cos(a)),Math.round(19+5*Math.sin(a)))}},
    {d:6,f:()=>{tmpClear();for(let a=Math.PI*.3;a<Math.PI*2.1;a+=.06)tmpStamp(Math.round(14+8*Math.cos(a)),Math.round(12+10*Math.sin(a)));tmpCircle(14,18,6,5)}},
    {d:7,f:()=>{tmpClear();tmpLine(6,5,21,5);tmpLine(21,5,12,24)}},
    {d:8,f:()=>{tmpClear();tmpCircle(14,9,6,5);tmpCircle(14,19,7,6)}},
    {d:9,f:()=>{tmpClear();tmpCircle(14,10,7,6);tmpLine(21,10,14,24)}}
  ];
  presetDefs.forEach(p=>{ p.f(); templates.push({digit:p.d, feat:extractFeatures(tmpGrid)}); });
}

// Temp grid for template generation (avoid polluting main grid)
let tmpGrid=Array.from({length:G},()=>new Float32Array(G));
function tmpClear(){ for(let r=0;r<G;r++) tmpGrid[r].fill(0); }
function tmpStamp(gx,gy){
  for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){
    const nx=gx+dx,ny=gy+dy;
    if(nx>=0&&nx<G&&ny>=0&&ny<G){
      const d=Math.abs(dx)+Math.abs(dy);
      tmpGrid[ny][nx]=Math.min(1,tmpGrid[ny][nx]+(d===0?1:d===1?.45:.15));
    }
  }
}
function tmpCircle(cx2,cy2,rx,ry){ for(let a=0;a<TAU;a+=.06) tmpStamp(Math.round(cx2+rx*Math.cos(a)),Math.round(cy2+ry*Math.sin(a))); }
function tmpLine(x0,y0,x1,y1){ const dx=x1-x0,dy=y1-y0,steps=Math.max(Math.abs(dx),Math.abs(dy),1)*2;for(let i=0;i<=steps;i++){const t=i/steps;tmpStamp(Math.round(x0+dx*t),Math.round(y0+dy*t));} }

function classify(){
  const fmaps=filters.map(f=>conv2d(grid,f.k));
  const pmaps=fmaps.map(fm=>maxPool(fm,2));
  const total=fmaps.map(energy).reduce((a,b)=>a+b,0);
  if(total<3) return {scores:new Float32Array(10),best:-1,fmaps,pmaps};

  const feat=extractFeatures(grid);
  // Compute distance to each template, convert to similarity scores
  const dists=new Float32Array(10).fill(Infinity);
  templates.forEach(t=>{
    const d=featDist(feat,t.feat);
    if(d<dists[t.digit]) dists[t.digit]=d;
  });

  // Convert distances to softmax probabilities (smaller dist = higher prob)
  const scores=new Float32Array(10);
  let minD=Infinity; for(let i=0;i<10;i++) if(dists[i]<minD) minD=dists[i];
  let sum=0;
  for(let i=0;i<10;i++){
    // Use negative distance as logit, with temperature scaling
    const logit=dists[i]<Infinity ? -(dists[i]-minD)*5 : -50;
    scores[i]=Math.exp(logit); sum+=scores[i];
  }
  for(let i=0;i<10;i++) scores[i]/=sum;
  let best=0; for(let i=1;i<10;i++) if(scores[i]>scores[best]) best=i;
  return {scores,best,fmaps,pmaps};
}

const OX=12,OY=28;
function cellAt(e){
  const r=c.getBoundingClientRect();
  return {gx:Math.floor(((e.clientX-r.left)*750/r.width-OX)/CS),
          gy:Math.floor(((e.clientY-r.top)*340/r.height-OY)/CS)};
}
function stamp(gx,gy){
  for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){
    const nx=gx+dx,ny=gy+dy;
    if(nx>=0&&nx<G&&ny>=0&&ny<G){
      const d=Math.abs(dx)+Math.abs(dy);
      grid[ny][nx]=Math.min(1,grid[ny][nx]+(d===0?1:d===1?.45:.15));
    }
  }
}
function linePaint(x0,y0,x1,y1){
  const dx=x1-x0,dy=y1-y0,steps=Math.max(Math.abs(dx),Math.abs(dy),1)*2;
  for(let i=0;i<=steps;i++){const t=i/steps;stamp(Math.round(x0+dx*t),Math.round(y0+dy*t));}
}
c.onmousedown=e=>{drawing=true;const p=cellAt(e);lastPt=p;stamp(p.gx,p.gy);render()};
c.onmousemove=e=>{if(!drawing)return;const p=cellAt(e);if(lastPt)linePaint(lastPt.gx,lastPt.gy,p.gx,p.gy);else stamp(p.gx,p.gy);lastPt=p;render()};
c.onmouseup=c.onmouseleave=()=>{drawing=false;lastPt=null};
c.ontouchstart=e=>{e.preventDefault();drawing=true;const p=cellAt(e.touches[0]);lastPt=p;stamp(p.gx,p.gy);render()};
c.ontouchmove=e=>{e.preventDefault();if(!drawing)return;const p=cellAt(e.touches[0]);if(lastPt)linePaint(lastPt.gx,lastPt.gy,p.gx,p.gy);else stamp(p.gx,p.gy);lastPt=p;render()};
c.ontouchend=()=>{drawing=false;lastPt=null};

function startScan(){
  if(animId) cancelAnimationFrame(animId);
  scanRow=0;
  (function tick(){scanRow+=.6;render();if(scanRow<G)animId=requestAnimationFrame(tick);else{scanRow=-1;animId=null;render();}})();
}

function render(){
  ctx.clearRect(0,0,750,340);
  const res=classify();

  // 1. Input Canvas
  ctx.fillStyle='#4ecdc4';ctx.font='700 11px Fira Code';ctx.fillText('1. Input  28\u00d728',OX,OY-8);
  ctx.fillStyle='#08081a';ctx.beginPath();ctx.roundRect(OX-1,OY-1,G*CS+2,G*CS+2,4);ctx.fill();
  for(let r=0;r<G;r++) for(let c2=0;c2<G;c2++){
    if(grid[r][c2]>.01){
      ctx.fillStyle=`rgba(230,228,222,${Math.min(grid[r][c2],1)})`;
      ctx.fillRect(OX+c2*CS,OY+r*CS,CS-.4,CS-.4);
    }
  }
  if(scanRow>=0&&scanRow<G){
    ctx.fillStyle='rgba(78,205,196,.18)';ctx.fillRect(OX,OY+Math.floor(scanRow)*CS,G*CS,CS*3);
    ctx.strokeStyle='#4ecdc4';ctx.lineWidth=1.5;ctx.beginPath();ctx.moveTo(OX,OY+scanRow*CS);ctx.lineTo(OX+G*CS,OY+scanRow*CS);ctx.stroke();
  }
  ctx.strokeStyle='#1e1e34';ctx.lineWidth=.5;ctx.beginPath();ctx.roundRect(OX-1,OY-1,G*CS+2,G*CS+2,4);ctx.stroke();

  // Arrow
  ctx.fillStyle='#4a475a';ctx.font='18px sans-serif';ctx.fillText('\u2192',OX+G*CS+6,OY+G*CS/2);

  // 2. Conv Feature Maps
  const fmX=222,fmY=OY;
  ctx.fillStyle='#ffd166';ctx.font='700 11px Fira Code';ctx.fillText('2. Convolution (3\u00d73)',fmX,fmY-8);
  const fmaps=res.fmaps||filters.map(f=>conv2d(grid,f.k));
  fmaps.forEach((fm,fi)=>{
    const fy=fmY+fi*70,fcs=2.6,col=filters[fi].c;
    ctx.fillStyle=col;ctx.font='600 8px Fira Code';ctx.fillText(filters[fi].n,fmX,fy+10);
    const kx=fmX,ky=fy+14,ks=7;
    filters[fi].k.forEach((row,kr)=>row.forEach((v,kc)=>{
      ctx.fillStyle=v>0?col+'aa':v<0?'#ff6b6b88':'#181830';
      ctx.fillRect(kx+kc*ks,ky+kr*ks,ks-1,ks-1);
    }));
    ctx.fillStyle='#4a475a';ctx.font='11px sans-serif';ctx.fillText('\u2192',kx+24,ky+11);
    const mx2=kx+38;let peak=0;
    for(const row of fm) for(const v of row) if(v>peak) peak=v;
    if(peak<.01) peak=1;
    for(let r=0;r<fm.length;r++) for(let c2=0;c2<fm[r].length;c2++){
      const a=fm[r][c2]/peak;
      if(a>.04){ctx.fillStyle=col+(Math.round(Math.min(a,1)*230).toString(16).padStart(2,'0'));
        ctx.fillRect(mx2+c2*fcs,ky+r*fcs,fcs,fcs);}
    }
  });

  // Arrow
  ctx.fillStyle='#4a475a';ctx.font='18px sans-serif';ctx.fillText('\u2192',370,fmY+90);

  // 3. Pooled Maps
  const pX=392,pY=OY;
  ctx.fillStyle='#ffd166';ctx.font='700 11px Fira Code';ctx.fillText('3. Max Pool 2\u00d72',pX,pY-8);
  const pmaps=res.pmaps||fmaps.map(fm=>maxPool(fm,2));
  pmaps.forEach((pm,fi)=>{
    const fy=pY+fi*70,pcs=4.5,col=filters[fi].c;
    ctx.fillStyle=col;ctx.font='600 8px Fira Code';ctx.fillText(filters[fi].n,pX,fy+10);
    const ky=fy+14;let peak=0;
    for(const row of pm) for(const v of row) if(v>peak) peak=v;
    if(peak<.01) peak=1;
    for(let r=0;r<pm.length;r++) for(let c2=0;c2<pm[r].length;c2++){
      const a=pm[r][c2]/peak;
      if(a>.04){ctx.fillStyle=col+(Math.round(Math.min(a,1)*230).toString(16).padStart(2,'0'));
        ctx.fillRect(pX+c2*pcs,ky+r*pcs,pcs,pcs);}
    }
  });

  // Arrow
  ctx.fillStyle='#4a475a';ctx.font='18px sans-serif';ctx.fillText('\u2192',510,pY+90);

  // 4. Classification
  const cX=535,cY=OY,hasInk=grid.some(row=>row.some(v=>v>.05));
  ctx.fillStyle='#ffd166';ctx.font='700 11px Fira Code';ctx.fillText('4. Dense \u2192 Softmax',cX,cY-8);

  if(hasInk&&res.best>=0){
    ctx.fillStyle='rgba(6,6,12,.92)';ctx.beginPath();ctx.roundRect(cX,cY+2,58,58,10);ctx.fill();
    ctx.save();ctx.shadowColor='#4ecdc4';ctx.shadowBlur=18;
    ctx.fillStyle='#4ecdc4';ctx.font='bold 42px Fira Code';ctx.textAlign='center';
    ctx.fillText(String(res.best),cX+29,cY+48);ctx.textAlign='left';ctx.restore();
    ctx.fillStyle='#7d7a8c';ctx.font='400 8px Fira Code';
    ctx.fillText((res.scores[res.best]*100).toFixed(1)+'%',cX+8,cY+70);
  }
  const bX=cX+68,bY=cY+2,bW=138,bH=14;
  for(let d=0;d<10;d++){
    const y=bY+d*(bH+3.5),isTop=hasInk&&d===res.best;
    ctx.fillStyle=isTop?'#4ecdc4':'#7d7a8c';ctx.font=(isTop?'700':'400')+' 9px Fira Code';
    ctx.fillText(String(d),bX-12,y+10);
    ctx.fillStyle='#0e0e1e';ctx.beginPath();ctx.roundRect(bX,y,bW,bH,3);ctx.fill();
    if(hasInk){
      const w=res.scores[d]*bW;
      ctx.fillStyle=isTop?'#4ecdc4bb':'#4a475a88';
      ctx.beginPath();ctx.roundRect(bX,y,Math.max(w,2),bH,3);ctx.fill();
      if(w>18){ctx.fillStyle='#e4e2df';ctx.font='500 7px Fira Code';ctx.fillText((res.scores[d]*100).toFixed(0)+'%',bX+4,y+10);}
    }
  }

  // Bottom
  ctx.fillStyle='rgba(6,6,12,.85)';ctx.beginPath();ctx.roundRect(12,258,726,72,8);ctx.fill();
  ctx.fillStyle='#7d7a8c';ctx.font='400 9px Fira Code';
  ctx.fillText('LeNet: Input(28\u00d728) \u2192 Conv(5\u00d75,6) \u2192 Pool \u2192 Conv(5\u00d75,16) \u2192 Pool \u2192 FC(120) \u2192 FC(84) \u2192 10 digits',22,276);
  ctx.fillText('Key: the same filter slides across the entire image \u2192 detects features regardless of position (translation invariance).',22,292);
  ctx.fillText('Real LeNet learns filters via backprop. Here we use hand-crafted edge detectors to illustrate the concept.',22,308);
  ctx.fillText('Try drawing different digits \u2014 notice how different filters activate for curves vs. straight lines!',22,324);
}

function clearGrid(){ for(let r=0;r<G;r++) grid[r].fill(0); }
function drawCircle(cx2,cy2,rx,ry){ for(let a=0;a<TAU;a+=.06) stamp(Math.round(cx2+rx*Math.cos(a)),Math.round(cy2+ry*Math.sin(a))); }
function drawLine2(x0,y0,x1,y1){ const dx=x1-x0,dy=y1-y0,steps=Math.max(Math.abs(dx),Math.abs(dy),1)*2;for(let i=0;i<=steps;i++){const t=i/steps;stamp(Math.round(x0+dx*t),Math.round(y0+dy*t));} }

const presets=[
  {n:'0',f:()=>{clearGrid();drawCircle(14,14,8,10)}},
  {n:'1',f:()=>{clearGrid();drawLine2(12,5,14,5);drawLine2(14,4,14,24);drawLine2(10,24,18,24)}},
  {n:'2',f:()=>{clearGrid();for(let a=Math.PI;a>=-0.1;a-=.08)stamp(Math.round(14+7*Math.cos(a)),Math.round(9+6*Math.sin(a)));drawLine2(21,9,8,23);drawLine2(8,23,22,23)}},
  {n:'3',f:()=>{clearGrid();for(let a=-Math.PI*.6;a<Math.PI*.6;a+=.08){stamp(Math.round(13+7*Math.cos(a)),Math.round(8+6*Math.sin(a)));stamp(Math.round(13+7*Math.cos(a)),Math.round(19+6*Math.sin(a)));}}},
  {n:'4',f:()=>{clearGrid();drawLine2(6,4,6,15);drawLine2(6,15,20,15);drawLine2(16,4,16,24)}},
  {n:'5',f:()=>{clearGrid();drawLine2(19,4,8,4);drawLine2(8,4,8,13);drawLine2(8,13,17,13);for(let a=-Math.PI*.5;a<Math.PI*.7;a+=.08) stamp(Math.round(15+6*Math.cos(a)),Math.round(19+5*Math.sin(a)))}},
  {n:'6',f:()=>{clearGrid();for(let a=Math.PI*.3;a<Math.PI*2.1;a+=.06) stamp(Math.round(14+8*Math.cos(a)),Math.round(12+10*Math.sin(a)));drawCircle(14,18,6,5)}},
  {n:'7',f:()=>{clearGrid();drawLine2(6,5,21,5);drawLine2(21,5,12,24)}},
  {n:'8',f:()=>{clearGrid();drawCircle(14,9,6,5);drawCircle(14,19,7,6)}},
  {n:'9',f:()=>{clearGrid();drawCircle(14,10,7,6);drawLine2(21,10,14,24)}}
];
const ctrl=addControls(el);
presets.forEach(p=>{const b=document.createElement('button');b.className='btn';b.textContent=p.n;b.onclick=()=>{p.f();startScan()};ctrl.appendChild(b);});
const clrBtn=document.createElement('button');clrBtn.className='btn';clrBtn.textContent='\u21bb Clear';
clrBtn.onclick=()=>{clearGrid();scanRow=-1;if(animId){cancelAnimationFrame(animId);animId=null;}render()};
ctrl.appendChild(clrBtn);
buildTemplates();
render();
})();

// ============================================================
//  LSTM — Gate Visualization (unchanged, already good)
// ============================================================
(function(){const el=$('demo-lstm'),[c,ctx]=createCanvas(el,750,340);
addHint(el,'Feed words into the LSTM. Watch the 3 gates control what to forget, store, and output.');
const words=['I','love','this','amazing','movie','!','It','was','terrible','though'];
let pos=-1,cellState=0,hidden=0,gateHistory=[];
function feedWord(){if(pos>=words.length-1)return;pos++;
let w=words[pos];let sentiment=({'love':.8,'amazing':.9,'movie':.1,'terrible':-.9,'!':.3,'I':0,'this':.05,'It':0,'was':0,'though':-.2})[w]||0;
let forgetG=sigmoid(hidden*1.5+sentiment*0.5-0.3);
let inputG=sigmoid(sentiment*2+hidden*0.3);
let candidate=Math.tanh(sentiment*1.5+hidden*0.2);
let outputG=sigmoid(hidden*0.5+cellState*0.3+sentiment);
cellState=forgetG*cellState+inputG*candidate;
hidden=outputG*Math.tanh(cellState);
gateHistory.push({w,f:forgetG,i:inputG,o:outputG,c:cellState,h:hidden});draw()}
function drawGate(x,y,w2,h,value,label,color){
ctx.fillStyle='#111120';ctx.beginPath();ctx.roundRect(x,y,w2,h,4);ctx.fill();
ctx.fillStyle=color+'66';ctx.beginPath();ctx.roundRect(x,y+h*(1-value),w2,h*value,4);ctx.fill();
ctx.strokeStyle=color;ctx.lineWidth=1;ctx.beginPath();ctx.roundRect(x,y,w2,h,4);ctx.stroke();
ctx.fillStyle='#e4e2df';ctx.font='600 9px Fira Code';ctx.textAlign='center';
ctx.fillText((value*100|0)+'%',x+w2/2,y+h/2+3);
ctx.fillStyle=color;ctx.font='600 8px Fira Code';ctx.fillText(label,x+w2/2,y-6);ctx.textAlign='left'}
function draw(){ctx.clearRect(0,0,750,340);
let wx=15,wy=12,ww=70;
words.forEach((w,i)=>{let x=wx+i*ww;let fed=i<=pos;
ctx.fillStyle=fed?(i===pos?'rgba(255,209,102,.15)':'rgba(78,205,196,.05)'):'#0c0c16';
ctx.beginPath();ctx.roundRect(x,wy,ww-4,26,5);ctx.fill();
ctx.strokeStyle=fed?(i===pos?'#ffd166':'#4ecdc433'):'#1e1e32';ctx.lineWidth=i===pos?2:1;
ctx.beginPath();ctx.roundRect(x,wy,ww-4,26,5);ctx.stroke();
ctx.fillStyle=fed?'#e4e2df':'#4a475a';ctx.font=(i===pos?'600':'400')+' 10px Fira Code';ctx.textAlign='center';
ctx.fillText(w,x+ww/2-2,wy+17);ctx.textAlign='left'});
let cx2=80,cy2=55,cw=280,ch=120;
ctx.fillStyle='rgba(78,205,196,.04)';ctx.beginPath();ctx.roundRect(cx2,cy2,cw,ch,12);ctx.fill();
ctx.strokeStyle='#4ecdc4';ctx.lineWidth=2;ctx.beginPath();ctx.roundRect(cx2,cy2,cw,ch,12);ctx.stroke();
ctx.fillStyle='#4ecdc4';ctx.font='700 12px Fira Code';ctx.fillText('LSTM Cell',cx2+90,cy2+20);
let gw=58,gh=60,gy=cy2+35;
let fg=gateHistory.length?gateHistory[gateHistory.length-1].f:0.5;
let ig=gateHistory.length?gateHistory[gateHistory.length-1].i:0.5;
let og=gateHistory.length?gateHistory[gateHistory.length-1].o:0.5;
drawGate(cx2+18,gy,gw,gh,fg,'Forget','#ff6b6b');
drawGate(cx2+88,gy,gw,gh,ig,'Input','#38bdf8');
drawGate(cx2+158,gy,gw,gh,og,'Output','#a78bfa');
let csNorm=(Math.tanh(cellState)+1)/2;
ctx.fillStyle='#111120';ctx.beginPath();ctx.roundRect(cx2+228,gy,38,gh,4);ctx.fill();
ctx.fillStyle='#ffd16666';ctx.beginPath();ctx.roundRect(cx2+228,gy+gh*(1-csNorm),38,gh*csNorm,4);ctx.fill();
ctx.strokeStyle='#ffd166';ctx.lineWidth=1;ctx.beginPath();ctx.roundRect(cx2+228,gy,38,gh,4);ctx.stroke();
ctx.fillStyle='#ffd166';ctx.font='600 8px Fira Code';ctx.textAlign='center';ctx.fillText('Cell',cx2+247,gy-6);
ctx.fillText(cellState.toFixed(2),cx2+247,gy+gh/2+3);ctx.textAlign='left';
let rx=385,ry=55;
ctx.fillStyle='rgba(6,6,12,.88)';ctx.beginPath();ctx.roundRect(rx,ry,355,120,10);ctx.fill();
ctx.fillStyle='#ff6b6b';ctx.font='600 10px Fira Code';ctx.fillText('Forget Gate: "Should I keep old memory?"',rx+10,ry+18);
ctx.fillStyle='#38bdf8';ctx.fillText('Input Gate: "How much new info to store?"',rx+10,ry+38);
ctx.fillStyle='#a78bfa';ctx.fillText('Output Gate: "What to reveal as output?"',rx+10,ry+58);
ctx.fillStyle='#ffd166';ctx.fillText('Cell State: long-term memory highway',rx+10,ry+78);
ctx.fillStyle='#7d7a8c';ctx.font='400 9px Fira Code';
ctx.fillText('Key insight: cell state flows through with minimal change',rx+10,ry+98);
ctx.fillText('\u2192 gradients can flow far back in time (no vanishing!)',rx+10,ry+112);
let hy2=188;
ctx.fillStyle='#ffd166';ctx.font='600 10px Fira Code';ctx.fillText('Gate values over time:',15,hy2);
if(gateHistory.length>0){let bw=Math.min(70,700/gateHistory.length);
gateHistory.forEach((g,gi)=>{let x=15+gi*bw;let bh=35;
ctx.fillStyle='#ff6b6b55';ctx.fillRect(x,hy2+8,bw/3-1,bh*g.f);
ctx.fillStyle='#38bdf855';ctx.fillRect(x+bw/3,hy2+8,bw/3-1,bh*g.i);
ctx.fillStyle='#a78bfa55';ctx.fillRect(x+2*bw/3,hy2+8,bw/3-1,bh*g.o);
ctx.fillStyle=gi===pos?'#ffd166':'#7d7a8c';ctx.font='500 8px Fira Code';ctx.textAlign='center';
ctx.fillText(g.w,x+bw/2,hy2+bh+22);ctx.textAlign='left'})}
let sy=240;
ctx.fillStyle='rgba(6,6,12,.85)';ctx.beginPath();ctx.roundRect(15,sy,720,35,6);ctx.fill();
ctx.fillStyle='#7d7a8c';ctx.font='500 9px Fira Code';ctx.fillText('Hidden output (sentiment): ',25,sy+14);
let sentBar=400,sentVal=(hidden+1)/2;
ctx.fillStyle='#111120';ctx.beginPath();ctx.roundRect(200,sy+5,sentBar,18,4);ctx.fill();
let grd=ctx.createLinearGradient(200,0,200+sentBar,0);grd.addColorStop(0,'#ff6b6b');grd.addColorStop(.5,'#7d7a8c');grd.addColorStop(1,'#34d399');
ctx.fillStyle=grd;ctx.beginPath();ctx.roundRect(200,sy+5,sentBar,18,4);ctx.fill();
ctx.fillStyle='#fff';ctx.fillRect(200+sentBar*sentVal-1.5,sy+2,3,24);
ctx.fillStyle='#e4e2df';ctx.font='600 9px Fira Code';ctx.fillText('Negative',620,sy+12);ctx.fillText('Positive',620,sy+26);
ctx.fillStyle='rgba(6,6,12,.85)';ctx.beginPath();ctx.roundRect(15,284,720,50,8);ctx.fill();
ctx.fillStyle='#4ecdc4';ctx.font='600 10px Fira Code';ctx.fillText('Why LSTM beats vanilla RNN:',25,302);
ctx.fillStyle='#e4e2df';ctx.font='400 9px Fira Code';
ctx.fillText('RNN: gradients shrink exponentially over long sequences \u2192 forgets early words',25,318);
ctx.fillText('LSTM: cell state highway + gates \u2192 can remember "love" even after many words!',25,332)}
const ctrl=addControls(el);
const fb2=document.createElement('button');fb2.className='btn';fb2.textContent='\u25b6 Feed Word';fb2.onclick=feedWord;
let tmr=null;const ab=document.createElement('button');ab.className='btn';ab.textContent='\u23e9 Auto';
ab.onclick=()=>{if(tmr){clearInterval(tmr);tmr=null;ab.classList.remove('active')}else{tmr=setInterval(()=>{feedWord();if(pos>=words.length-1){clearInterval(tmr);tmr=null;ab.classList.remove('active')}},500);ab.classList.add('active')}};
const rst=document.createElement('button');rst.className='btn';rst.textContent='\u21bb Reset';
rst.onclick=()=>{pos=-1;cellState=0;hidden=0;gateHistory=[];if(tmr){clearInterval(tmr);tmr=null;ab.classList.remove('active')}draw()};
ctrl.appendChild(fb2);ctrl.appendChild(ab);ctrl.appendChild(rst);draw()})();

// ============================================================
//  SVM — Maximum-Margin Classifier (unchanged)
// ============================================================
(function(){const el=$('demo-svm'),[c,ctx]=createCanvas(el,750,320);
addHint(el,'Left-click = Red, Right-click = Blue. Watch SVM find the maximum-margin boundary. Support vectors are circled.');
let pts=[];function init(){pts=[];for(let i=0;i<10;i++){pts.push({x:rand(40,300),y:rand(40,280),c:0});pts.push({x:rand(450,710),y:rand(40,280),c:1})}}
init();
function solveSVM(){if(pts.length<4)return null;
let bestW=null,bestB=0,bestMargin=0;
for(let trial=0;trial<200;trial++){let i=randInt(0,pts.length),j=randInt(0,pts.length);
if(pts[i].c===pts[j].c)continue;
let mx=(pts[i].x+pts[j].x)/2,my=(pts[i].y+pts[j].y)/2;
let nx=pts[j].x-pts[i].x,ny=pts[j].y-pts[i].y;
let len=Math.hypot(nx,ny);if(len<1)continue;nx/=len;ny/=len;
let b2=-(nx*mx+ny*my);
let minDist=Infinity,valid=true;
pts.forEach(p=>{let d=(nx*p.x+ny*p.y+b2)*(p.c?1:-1);if(d<0)valid=false;minDist=Math.min(minDist,Math.abs(d))});
if(valid&&minDist>bestMargin){bestMargin=minDist;bestW={x:nx,y:ny};bestB=b2}}
return bestW?{w:bestW,b:bestB,margin:bestMargin}:null}
function draw(){ctx.clearRect(0,0,750,320);
let sol=solveSVM();
if(sol){let{w,b,margin}=sol;
for(let py=0;py<320;py+=12)for(let px=0;px<750;px+=12){
let d=w.x*px+w.y*py+b;
ctx.fillStyle=d>=0?'rgba(56,189,248,0.05)':'rgba(255,107,107,0.05)';ctx.fillRect(px,py,12,12)}
ctx.save();ctx.shadowColor='#ffd166';ctx.shadowBlur=10;ctx.strokeStyle='#ffd166';ctx.lineWidth=2.5;ctx.beginPath();
if(Math.abs(w.y)>1e-6){ctx.moveTo(0,(-b)/w.y);ctx.lineTo(750,(-b-w.x*750)/w.y)}
else{let xv=-b/w.x;ctx.moveTo(xv,0);ctx.lineTo(xv,320)}
ctx.stroke();ctx.restore();
ctx.strokeStyle='rgba(255,209,102,.2)';ctx.lineWidth=1;ctx.setLineDash([5,5]);
if(Math.abs(w.y)>1e-6){
ctx.beginPath();ctx.moveTo(0,(-b+margin)/w.y);ctx.lineTo(750,(-b-w.x*750+margin)/w.y);ctx.stroke();
ctx.beginPath();ctx.moveTo(0,(-b-margin)/w.y);ctx.lineTo(750,(-b-w.x*750-margin)/w.y);ctx.stroke()}
ctx.setLineDash([]);
let svs=pts.filter(p=>{let d=Math.abs(w.x*p.x+w.y*p.y+b);return d<margin*1.2});
svs.forEach(p=>{ctx.beginPath();ctx.arc(p.x,p.y,12,0,TAU);ctx.strokeStyle='#ffd166';ctx.lineWidth=2;ctx.stroke()});
ctx.fillStyle='rgba(6,6,12,.88)';ctx.beginPath();ctx.roundRect(8,8,220,42,8);ctx.fill();
ctx.fillStyle='#ffd166';ctx.font='600 11px Fira Code';ctx.fillText('Margin: '+margin.toFixed(1)+'px',18,28);
ctx.fillStyle='#7d7a8c';ctx.font='400 9px Fira Code';ctx.fillText('Support vectors: '+svs.length+' (circled)',18,44)}
pts.forEach(p=>{ctx.save();ctx.shadowColor=p.c?'#38bdf8':'#ff6b6b';ctx.shadowBlur=5;
ctx.beginPath();ctx.arc(p.x,p.y,6,0,TAU);ctx.fillStyle=p.c?'#38bdf8':'#ff6b6b';ctx.fill();ctx.restore()});
ctx.fillStyle='rgba(6,6,12,.85)';ctx.beginPath();ctx.roundRect(15,284,720,30,6);ctx.fill();
ctx.fillStyle='#7d7a8c';ctx.font='400 9px Fira Code';
ctx.fillText('SVM maximizes the gap (margin) between classes. Only the closest points (support vectors) matter!',25,303)}
c.onclick=e=>{let r=c.getBoundingClientRect();pts.push({x:(e.clientX-r.left)*750/r.width,y:(e.clientY-r.top)*320/r.height,c:0});draw()};
c.oncontextmenu=e=>{e.preventDefault();let r=c.getBoundingClientRect();pts.push({x:(e.clientX-r.left)*750/r.width,y:(e.clientY-r.top)*320/r.height,c:1});draw()};
const ctrl=addControls(el);
const rst=document.createElement('button');rst.className='btn';rst.textContent='\u21bb Reset';rst.onclick=()=>{init();draw()};
ctrl.appendChild(rst);draw()})();

// ============================================================
//  GMM + EM (unchanged)
// ============================================================
(function(){const el=$('demo-gmm'),[c,ctx]=createCanvas(el,750,320);
addHint(el,'Click "Step EM" to run one E+M iteration. Watch clusters converge from random initialization.');
let pts=[],K=3,means=[],sigmas=[],pis=[];
function init(){pts=[];
let centers=[{x:180,y:100},{x:400,y:220},{x:600,y:100}];
centers.forEach(c2=>{for(let i=0;i<30;i++)pts.push({x:c2.x+rand(-70,70),y:c2.y+rand(-60,60),resp:Array(K).fill(1/K)})});
means=centers.map(()=>({x:rand(100,650),y:rand(50,270)}));sigmas=Array(K).fill(50);pis=Array(K).fill(1/K)}
init();
let colors=['#ff6b6b','#38bdf8','#ffd166'],emStep=0;
function gaussian(x,y,mx,my,s){let d=((x-mx)**2+(y-my)**2)/(2*s*s);return Math.exp(-d)/(TAU*s*s)}
function eStep(){pts.forEach(p=>{let total=0;let r=means.map((m,k)=>{let v=pis[k]*gaussian(p.x,p.y,m.x,m.y,sigmas[k]);total+=v;return v});
p.resp=r.map(v=>v/(total||1e-10))})}
function mStep(){for(let k=0;k<K;k++){let N2=pts.reduce((a,p)=>a+p.resp[k],0);if(N2<1e-6)continue;
means[k].x=pts.reduce((a,p)=>a+p.resp[k]*p.x,0)/N2;
means[k].y=pts.reduce((a,p)=>a+p.resp[k]*p.y,0)/N2;
sigmas[k]=Math.sqrt(pts.reduce((a,p)=>a+p.resp[k]*((p.x-means[k].x)**2+(p.y-means[k].y)**2),0)/(2*N2));
sigmas[k]=Math.max(sigmas[k],10);pis[k]=N2/pts.length}}
function draw(){ctx.clearRect(0,0,750,320);
means.forEach((m,k)=>{let s=sigmas[k];for(let r=3;r>=1;r--){
ctx.beginPath();ctx.arc(m.x,m.y,s*r*.7,0,TAU);ctx.strokeStyle=colors[k]+'33';ctx.lineWidth=1;ctx.stroke()}});
pts.forEach(p=>{let maxK=0,maxR=0;p.resp.forEach((r,k)=>{if(r>maxR){maxR=r;maxK=k}});
ctx.beginPath();ctx.arc(p.x,p.y,4,0,TAU);ctx.fillStyle=colors[maxK]+(Math.round(Math.max(maxR,.3)*200).toString(16).padStart(2,'0'));ctx.fill()});
means.forEach((m,k)=>{ctx.save();ctx.shadowColor=colors[k];ctx.shadowBlur=12;
ctx.beginPath();ctx.arc(m.x,m.y,8,0,TAU);ctx.fillStyle=colors[k];ctx.fill();ctx.restore();
ctx.fillStyle='#000';ctx.font='bold 9px Fira Code';ctx.textAlign='center';ctx.fillText('\u03bc'+(k+1),m.x,m.y+3);ctx.textAlign='left'});
ctx.fillStyle='rgba(6,6,12,.88)';ctx.beginPath();ctx.roundRect(8,8,200,28,6);ctx.fill();
ctx.fillStyle='#ffd166';ctx.font='600 11px Fira Code';ctx.fillText('EM Iteration: '+emStep,18,28);
ctx.fillStyle='rgba(6,6,12,.85)';ctx.beginPath();ctx.roundRect(15,280,720,35,8);ctx.fill();
ctx.fillStyle='#4ecdc4';ctx.font='500 9px Fira Code';
ctx.fillText('E-step: compute P(cluster k | point) using current means/variances',25,295);
ctx.fillText('M-step: update means/variances using soft assignments \u2192 iterate until convergence!',25,310)}
const ctrl=addControls(el);
const sb=document.createElement('button');sb.className='btn';sb.textContent='\u25b6 Step EM';sb.onclick=()=>{eStep();mStep();emStep++;draw()};
let tmr=null;const ab=document.createElement('button');ab.className='btn';ab.textContent='\u23e9 Auto';
ab.onclick=()=>{if(tmr){clearInterval(tmr);tmr=null;ab.classList.remove('active')}else{tmr=setInterval(()=>{eStep();mStep();emStep++;draw()},200);ab.classList.add('active')}};
const rst2=document.createElement('button');rst2.className='btn';rst2.textContent='\u21bb Reset';
rst2.onclick=()=>{init();emStep=0;if(tmr){clearInterval(tmr);tmr=null;ab.classList.remove('active')}draw()};
ctrl.appendChild(sb);ctrl.appendChild(ab);ctrl.appendChild(rst2);draw()})();

// ============================================================
//  RANDOM FOREST — Individual tree panels with colored regions
// ============================================================
(function(){
const el=$('demo-rf'),[c,ctx]=createCanvas(el,750,380);
addHint(el,'Grow trees one by one. Each tree shows its own colored decision regions. The "Forest" panel shows the majority vote.');

const DW=300,DH=220;
let pts=[];
function seedPts(){
  pts=[];
  for(let i=0;i<22;i++) pts.push({x:rand(15,DW*.48),y:rand(15,DH-15),c:0});
  for(let i=0;i<22;i++) pts.push({x:rand(DW*.52,DW-15),y:rand(15,DH-15),c:1});
  for(let i=0;i<6;i++){pts.push({x:rand(DW*.35,DW*.65),y:rand(15,DH*.4),c:0});
    pts.push({x:rand(DW*.35,DW*.65),y:rand(DH*.6,DH-15),c:1});}
}
seedPts();

function buildTree(sub,depth){
  if(depth<=0||sub.length<4){const c0=sub.filter(p=>p.c===0).length;return{leaf:true,cls:c0>=sub.length-c0?0:1}}
  const bag=[];for(let i=0;i<sub.length;i++)bag.push(sub[randInt(0,sub.length)]);
  let bestGini=2,bestAxis='x',bestVal=DW/2;
  for(const axis of['x','y']){const vals=bag.map(p=>p[axis]).sort((a,b)=>a-b);
    for(let q=.15;q<=.85;q+=.1){const v=vals[Math.floor(vals.length*q)];
      const left=bag.filter(p=>p[axis]<=v),right=bag.filter(p=>p[axis]>v);
      if(left.length<2||right.length<2)continue;
      const gini=s=>{const n=s.length,p0=s.filter(p=>p.c===0).length/n;return 1-p0*p0-(1-p0)*(1-p0)};
      const g=(left.length*gini(left)+right.length*gini(right))/bag.length;
      if(g<bestGini){bestGini=g;bestAxis=axis;bestVal=v;}}}
  const lp=sub.filter(p=>p[bestAxis]<=bestVal),rp=sub.filter(p=>p[bestAxis]>bestVal);
  if(lp.length<2||rp.length<2){const c0=sub.filter(p=>p.c===0).length;return{leaf:true,cls:c0>=sub.length-c0?0:1}}
  return{leaf:false,axis:bestAxis,val:bestVal,left:buildTree(lp,depth-1),right:buildTree(rp,depth-1)};
}
function treePredict(t,x,y){if(t.leaf)return t.cls;return(t.axis==='x'?x:y)<=t.val?treePredict(t.left,x,y):treePredict(t.right,x,y)}
function treeSplits(t,list){if(!list)list=[];if(!t.leaf){list.push({axis:t.axis,val:t.val});treeSplits(t.left,list);treeSplits(t.right,list)}return list}

let trees=[];
const TC=['#ffd166','#38bdf8','#a78bfa','#ff6b6b','#4ecdc4','#f472b6'];

function drawRegions(tree,ox,oy,pw,ph,alpha){
  const step=4;
  for(let py2=0;py2<ph;py2+=step)for(let px2=0;px2<pw;px2+=step){
    const cls=treePredict(tree,px2/pw*DW,py2/ph*DH);
    ctx.fillStyle=cls===0?`rgba(255,107,107,${alpha})`:`rgba(56,189,248,${alpha})`;
    ctx.fillRect(ox+px2,oy+py2,step,step);}
}
function drawDots(ox,oy,pw,ph,sz){
  pts.forEach(p=>{ctx.beginPath();ctx.arc(ox+p.x/DW*pw,oy+p.y/DH*ph,sz,0,TAU);
    ctx.fillStyle=p.c===0?'#ff6b6b':'#38bdf8';ctx.fill()});
}

function draw(){
  ctx.clearRect(0,0,750,380);
  const n=trees.length, maxShow=Math.min(n,5);
  const CW=750, CH=380;
  const pad=6, topY=4;

  if(n===0){
    // Full-width data panel
    const pw=CW-20, ph=280;
    ctx.fillStyle='rgba(6,6,12,.92)';ctx.beginPath();ctx.roundRect(10,topY,pw,ph,8);ctx.fill();
    ctx.strokeStyle='#ffd16644';ctx.lineWidth=1;ctx.beginPath();ctx.roundRect(10,topY,pw,ph,8);ctx.stroke();
    ctx.fillStyle='#ffd166';ctx.font='700 11px Fira Code';ctx.fillText('Data Points \u2014 Two classes with overlap',20,topY+18);
    ctx.fillStyle='#7d7a8c';ctx.font='400 9px Fira Code';ctx.fillText('Click "+1 Tree" to grow decision trees. Each tree will learn a different partition of this data.',20,topY+33);
    drawDots(20,topY+40,pw-20,ph-50,5);
    // Legend
    ctx.beginPath();ctx.arc(CW-150,topY+18,5,0,TAU);ctx.fillStyle='#ff6b6b';ctx.fill();
    ctx.fillStyle='#ff6b6b';ctx.font='500 9px Fira Code';ctx.fillText('Class A',CW-140,topY+22);
    ctx.beginPath();ctx.arc(CW-80,topY+18,5,0,TAU);ctx.fillStyle='#38bdf8';ctx.fill();
    ctx.fillStyle='#38bdf8';ctx.font='500 9px Fira Code';ctx.fillText('Class B',CW-70,topY+22);
    // Bottom explanation
    const ey=topY+ph+8;
    ctx.fillStyle='rgba(6,6,12,.85)';ctx.beginPath();ctx.roundRect(10,ey,CW-20,76,8);ctx.fill();
    ctx.fillStyle='#7d7a8c';ctx.font='400 9px Fira Code';
    ctx.fillText('Each tree sees a random bootstrap sample (bagging) and considers random feature subsets at each split.',20,ey+18);
    ctx.fillText('Individual trees are noisy and overfit, but the majority vote averages out errors \u2192 strong ensemble!',20,ey+34);
    ctx.fillText('This is "Bootstrap AGGregatING" \u2014 parallelizable and robust. Add more trees to see accuracy improve.',20,ey+50);
    ctx.fillText('\ud83d\udca1 Compare: Random Forest (parallel + diversity) vs. AdaBoost below (sequential + focus on mistakes)',20,ey+66);
    return;
  }

  // === Layout with trees: individual panels (top row) + forest panel (right, taller) ===
  // Tree panels: fit maxShow panels on the left, forest panel on the right
  const forestW=Math.max(260, CW*0.38);
  const treesAreaW=CW-forestW-pad*2-10;
  const pw=Math.floor((treesAreaW-pad*(maxShow-1))/maxShow);
  const ph=220;  // taller panels

  // Individual tree panels
  for(let i=0;i<maxShow;i++){
    const ti=n<=5?i:n-5+i;
    const ox=8+i*(pw+pad), col=TC[ti%TC.length];
    ctx.fillStyle='rgba(6,6,12,.92)';ctx.beginPath();ctx.roundRect(ox,topY,pw,ph,8);ctx.fill();
    ctx.strokeStyle=col+'55';ctx.lineWidth=1;ctx.beginPath();ctx.roundRect(ox,topY,pw,ph,8);ctx.stroke();
    ctx.fillStyle=col;ctx.font='700 9px Fira Code';ctx.fillText('Tree '+(ti+1),ox+6,topY+14);
    const inner=4;
    drawRegions(trees[ti],ox+inner,topY+20,pw-inner*2,ph-28,.22);
    const splits=treeSplits(trees[ti]);
    splits.forEach(s=>{ctx.strokeStyle=col+'77';ctx.lineWidth=1;ctx.setLineDash([3,3]);ctx.beginPath();
      if(s.axis==='x'){const sx=ox+inner+s.val/DW*(pw-inner*2);ctx.moveTo(sx,topY+20);ctx.lineTo(sx,topY+ph-8)}
      else{const sy=topY+20+s.val/DH*(ph-28);ctx.moveTo(ox+inner,sy);ctx.lineTo(ox+pw-inner,sy)}
      ctx.stroke();ctx.setLineDash([])});
    drawDots(ox+inner,topY+20,pw-inner*2,ph-28,2.5);
    const acc=pts.filter(p=>treePredict(trees[ti],p.x,p.y)===p.c).length;
    ctx.fillStyle=col;ctx.font='600 8px Fira Code';ctx.fillText('Acc: '+(acc/pts.length*100).toFixed(0)+'%',ox+6,topY+ph-6);
  }
  if(n>5){ctx.fillStyle='#7d7a8c';ctx.font='400 8px Fira Code';ctx.fillText('(last 5 of '+n+')',8,topY+ph+12)}

  // === Forest panel (right side, full height) ===
  const fx=CW-forestW-4, fy=topY, fh=ph;
  ctx.fillStyle='rgba(6,6,12,.92)';ctx.beginPath();ctx.roundRect(fx,fy,forestW,fh,8);ctx.fill();
  ctx.strokeStyle='#34d39955';ctx.lineWidth=1.5;ctx.beginPath();ctx.roundRect(fx,fy,forestW,fh,8);ctx.stroke();
  ctx.fillStyle='#34d399';ctx.font='700 11px Fira Code';ctx.fillText('\ud83c\udf32 Forest Majority Vote ('+n+' trees)',fx+8,fy+16);
  // Regions
  const fi=6, fpw=forestW-fi*2, fph=fh-50;
  const step2=4;
  for(let py2=0;py2<fph;py2+=step2)for(let px2=0;px2<fpw;px2+=step2){
    let v0=0,v1=0;trees.forEach(t=>treePredict(t,px2/fpw*DW,py2/fph*DH)===0?v0++:v1++);
    const cls=v0>v1?0:1, conf=Math.max(v0,v1)/n, a=.06+conf*.2;
    ctx.fillStyle=cls===0?`rgba(255,107,107,${a})`:`rgba(56,189,248,${a})`;
    ctx.fillRect(fx+fi+px2,fy+24+py2,step2,step2);}
  drawDots(fx+fi,fy+24,fpw,fph,3.5);
  // Accuracy badge
  const fAcc=pts.filter(p=>{let v0=0,v1=0;trees.forEach(t=>treePredict(t,p.x,p.y)===0?v0++:v1++);return(v0>v1?0:1)===p.c}).length;
  const fA=fAcc/pts.length;
  ctx.fillStyle='rgba(6,6,12,.85)';ctx.beginPath();ctx.roundRect(fx+fi,fy+fph+28,fpw,18,4);ctx.fill();
  ctx.fillStyle='#34d39988';ctx.beginPath();ctx.roundRect(fx+fi,fy+fph+28,fpw*fA,18,4);ctx.fill();
  ctx.fillStyle='#e4e2df';ctx.font='bold 10px Fira Code';ctx.fillText('Forest Accuracy: '+(fA*100).toFixed(0)+'%',fx+fi+6,fy+fph+41);

  // === Bottom: accuracy comparison + explanation ===
  const by=topY+ph+8+(n>5?14:0);
  ctx.fillStyle='rgba(6,6,12,.9)';ctx.beginPath();ctx.roundRect(8,by,CW-16,CH-by-6,8);ctx.fill();

  // Accuracy bars
  let bestTA=0;trees.forEach(t=>{const a=pts.filter(p=>treePredict(t,p.x,p.y)===p.c).length/pts.length;if(a>bestTA)bestTA=a});
  const bx2=16, bw2=280, bh2=16;
  ctx.fillStyle='#ffd166';ctx.font='700 10px Fira Code';ctx.fillText('Accuracy:',bx2,by+16);
  ctx.fillStyle='#ff6b6b';ctx.font='500 9px Fira Code';ctx.fillText('Best single tree:',bx2,by+34);
  ctx.fillStyle='#1a1a2e';ctx.beginPath();ctx.roundRect(bx2+110,by+24,bw2,bh2,3);ctx.fill();
  ctx.fillStyle='#ff6b6b88';ctx.beginPath();ctx.roundRect(bx2+110,by+24,bw2*bestTA,bh2,3);ctx.fill();
  ctx.fillStyle='#e4e2df';ctx.font='600 9px Fira Code';ctx.fillText((bestTA*100).toFixed(0)+'%',bx2+115+bw2*bestTA,by+37);

  ctx.fillStyle='#34d399';ctx.font='500 9px Fira Code';ctx.fillText('Forest ('+n+' trees):',bx2,by+56);
  ctx.fillStyle='#1a1a2e';ctx.beginPath();ctx.roundRect(bx2+110,by+46,bw2,bh2,3);ctx.fill();
  ctx.fillStyle='#34d39988';ctx.beginPath();ctx.roundRect(bx2+110,by+46,bw2*fA,bh2,3);ctx.fill();
  ctx.fillStyle='#e4e2df';ctx.font='600 9px Fira Code';ctx.fillText((fA*100).toFixed(0)+'%',bx2+115+bw2*fA,by+59);

  // Explanation on the right side of accuracy bars
  ctx.fillStyle='#7d7a8c';ctx.font='400 9px Fira Code';
  ctx.fillText('Each tree sees a random bootstrap sample + random features.',bx2+420,by+16);
  ctx.fillText('Individual trees overfit, but voting averages out errors.',bx2+420,by+32);
  ctx.fillText('More trees = smoother boundary = better generalization!',bx2+420,by+48);
  ctx.fillStyle='#4ecdc4';ctx.font='500 9px Fira Code';
  ctx.fillText('\ud83d\udca1 This is "Bootstrap AGGregatING" (bagging).',bx2+420,by+64);
}

const ctrl=addControls(el);
[{n:'\ud83c\udf33 +1 Tree',f:1},{n:'\ud83c\udf32 +5 Trees',f:5},{n:'\ud83c\udf3f +20 Trees',f:20}].forEach(o=>{
  const b=document.createElement('button');b.className='btn';b.textContent=o.n;
  b.onclick=()=>{for(let i=0;i<o.f;i++)trees.push(buildTree(pts,3));draw()};ctrl.appendChild(b)});
const rst=document.createElement('button');rst.className='btn';rst.textContent='\u21bb Reset';
rst.onclick=()=>{trees=[];seedPts();draw()};ctrl.appendChild(rst);draw();
})();

// ============================================================
//  ADABOOST — Clear Step-by-Step with Weight Visualization
// ============================================================
(function(){
const el=$('demo-ada'),[c,ctx]=createCanvas(el,750,480);
addHint(el,'Click "+1 Round" to add a weak learner. Watch: (1) bigger circles = higher weight, (2) each stump targets hardest mistakes, (3) ensemble accuracy climbs.');

const DW2=280,DH2=200;
let pts=[],stumps=[],round=0;

function seedPts(){
  pts=[];stumps=[];round=0;
  for(let i=0;i<14;i++){pts.push({x:rand(15,DW2*.45),y:rand(15,DH2-15),c:0,w:1});
    pts.push({x:rand(DW2*.55,DW2-15),y:rand(15,DH2-15),c:1,w:1})}
  for(let i=0;i<5;i++){pts.push({x:rand(DW2*.3,DW2*.7),y:rand(15,DH2*.45),c:0,w:1});
    pts.push({x:rand(DW2*.3,DW2*.7),y:rand(DH2*.55,DH2-15),c:1,w:1})}
  const n=pts.length;pts.forEach(p=>p.w=1/n);
}
seedPts();

function addStump(){
  round++;
  const totalW=pts.reduce((a,p)=>a+p.w,0);
  let bestErr=Infinity,bestStump=null;
  for(const axis of['x','y']){
    const vals=pts.map(p=>p[axis]).sort((a,b)=>a-b);
    for(let q=.08;q<=.92;q+=.04){const v=vals[Math.floor(vals.length*q)];
      for(const flip of[0,1]){let err=0;
        pts.forEach(p=>{if((p[axis]<=v?flip:1-flip)!==p.c)err+=p.w});err/=totalW;
        if(err<bestErr){bestErr=err;bestStump={axis,value:v,flip,err}}}}}
  if(!bestStump||bestErr>=.5)return;
  const alpha=.5*Math.log((1-bestErr)/(bestErr+1e-10));
  bestStump.alpha=alpha;bestStump.round=round;stumps.push(bestStump);
  pts.forEach(p=>{const pred=p[bestStump.axis]<=bestStump.value?bestStump.flip:1-bestStump.flip;
    p.w*=Math.exp(alpha*(pred!==p.c?1:-1))});
  const wSum=pts.reduce((a,p)=>a+p.w,0);pts.forEach(p=>p.w/=wSum);
  draw();
}

function ensemblePredict(p){
  if(!stumps.length)return -1;
  let score=0;stumps.forEach(s=>{const pred=p[s.axis]<=s.value?s.flip:1-s.flip;score+=s.alpha*(pred?1:-1)});
  return score>=0?1:0;
}

function drawPts(ox,oy,pw,ph,weighted){
  const maxW=Math.max(...pts.map(p=>p.w),.001);
  pts.forEach(p=>{const px2=ox+p.x/DW2*pw,py2=oy+p.y/DH2*ph;
    const r=weighted?3+p.w/maxW*9:4;
    const wrong=stumps.length>0&&ensemblePredict(p)!==p.c;
    ctx.globalAlpha=.85;ctx.beginPath();ctx.arc(px2,py2,r,0,TAU);
    ctx.fillStyle=p.c===0?'#ff6b6b':'#38bdf8';ctx.fill();ctx.globalAlpha=1;
    if(wrong){ctx.strokeStyle='#ffd166';ctx.lineWidth=2;ctx.beginPath();ctx.arc(px2,py2,r+2,0,TAU);ctx.stroke()}
  });
}

function draw(){
  ctx.clearRect(0,0,750,480);
  const ns=stumps.length;

  // LEFT: Weighted Data
  const lx=10,ly=8,lw=290,lh=230;
  ctx.fillStyle='rgba(6,6,12,.92)';ctx.beginPath();ctx.roundRect(lx,ly,lw,lh,8);ctx.fill();
  ctx.strokeStyle='#ffd16644';ctx.lineWidth=1;ctx.beginPath();ctx.roundRect(lx,ly,lw,lh,8);ctx.stroke();
  ctx.fillStyle='#ffd166';ctx.font='700 10px Fira Code';
  ctx.fillText(ns===0?'Data (equal weights)':'Round '+round+': Weighted Data',lx+8,ly+15);
  ctx.fillStyle='#7d7a8c';ctx.font='400 8px Fira Code';
  ctx.fillText(ns===0?'All points start with equal weight 1/N':'Bigger = higher weight (harder examples)',lx+8,ly+27);
  // Current stump line
  if(ns>0){const s=stumps[ns-1];
    ctx.strokeStyle='#ffd166aa';ctx.lineWidth=2;ctx.setLineDash([6,4]);ctx.beginPath();
    if(s.axis==='x'){const sx=lx+8+s.value/DW2*(lw-16);ctx.moveTo(sx,ly+32);ctx.lineTo(sx,ly+lh-4)}
    else{const sy=ly+32+s.value/DH2*(lh-36);ctx.moveTo(lx+4,sy);ctx.lineTo(lx+lw-4,sy)}
    ctx.stroke();ctx.setLineDash([]);
    ctx.fillStyle='#ffd166';ctx.font='600 8px Fira Code';
    ctx.fillText('Stump '+ns+': '+s.axis+'\u2264'+s.value.toFixed(0)+' (\u03b1='+(s.alpha).toFixed(2)+')',lx+8,ly+lh-6)}
  drawPts(lx+8,ly+32,lw-16,lh-36,true);

  // RIGHT: Combined Ensemble
  const rx=310,ry=8,rw=290,rh=230;
  ctx.fillStyle='rgba(6,6,12,.92)';ctx.beginPath();ctx.roundRect(rx,ry,rw,rh,8);ctx.fill();
  ctx.strokeStyle='#34d39944';ctx.lineWidth=1;ctx.beginPath();ctx.roundRect(rx,ry,rw,rh,8);ctx.stroke();
  ctx.fillStyle='#34d399';ctx.font='700 10px Fira Code';
  ctx.fillText(ns===0?'Ensemble (no stumps yet)':'Ensemble: '+ns+' Stumps Combined',rx+8,ry+15);
  if(ns>0){
    const step=6;
    for(let py2=0;py2<rh-36;py2+=step)for(let px2=0;px2<rw-16;px2+=step){
      let score=0;stumps.forEach(s=>{const val2=s.axis==='x'?px2/(rw-16)*DW2:py2/(rh-36)*DH2;
        const pr=val2<=s.value?s.flip:1-s.flip;score+=s.alpha*(pr?1:-1)});
      const cls=score>=0?1:0,conf=Math.min(Math.abs(score)/2,1),a=.06+conf*.16;
      ctx.fillStyle=cls===0?`rgba(255,107,107,${a})`:`rgba(56,189,248,${a})`;
      ctx.fillRect(rx+8+px2,ry+32+py2,step,step);}
    const acc=pts.filter(p=>ensemblePredict(p)===p.c).length;
    ctx.fillStyle='#34d399';ctx.font='bold 11px Fira Code';
    ctx.fillText('Acc: '+(acc/pts.length*100).toFixed(0)+'%',rx+rw-80,ry+15)}
  drawPts(rx+8,ry+32,rw-16,rh-36,false);

  // FAR RIGHT: Stump Timeline
  const tx=612,ty=8,tw=130,th=230;
  ctx.fillStyle='rgba(6,6,12,.92)';ctx.beginPath();ctx.roundRect(tx,ty,tw,th,8);ctx.fill();
  ctx.strokeStyle='#a78bfa44';ctx.lineWidth=1;ctx.beginPath();ctx.roundRect(tx,ty,tw,th,8);ctx.stroke();
  ctx.fillStyle='#a78bfa';ctx.font='700 9px Fira Code';ctx.fillText('Stump Timeline',tx+8,ty+15);
  const ms=Math.min(ns,10);
  for(let i=0;i<ms;i++){
    const si=ns<=10?i:ns-10+i,s=stumps[si],sy2=ty+24+i*19,cur=si===ns-1;
    ctx.fillStyle=cur?'#ffd166':'#4a475a';ctx.beginPath();ctx.arc(tx+14,sy2+6,4,0,TAU);ctx.fill();
    if(i<ms-1){ctx.strokeStyle='#2a2a3e';ctx.lineWidth=1;ctx.beginPath();ctx.moveTo(tx+14,sy2+10);ctx.lineTo(tx+14,sy2+19);ctx.stroke()}
    ctx.fillStyle=cur?'#e4e2df':'#7d7a8c';ctx.font=(cur?'600':'400')+' 8px Fira Code';
    ctx.fillText(s.axis+'\u2264'+s.value.toFixed(0),tx+24,sy2+5);
    const bw3=48,aw=Math.min(s.alpha/2,1)*bw3;
    ctx.fillStyle='#1a1a2e';ctx.beginPath();ctx.roundRect(tx+24,sy2+8,bw3,5,2);ctx.fill();
    ctx.fillStyle=cur?'#ffd166aa':'#a78bfa66';ctx.beginPath();ctx.roundRect(tx+24,sy2+8,aw,5,2);ctx.fill();
    ctx.fillStyle='#7d7a8c';ctx.font='400 6px Fira Code';ctx.fillText('\u03b1='+s.alpha.toFixed(2),tx+76,sy2+13);
  }
  if(ns===0){ctx.fillStyle='#4a475a';ctx.font='400 8px Fira Code';ctx.fillText('No stumps yet.',tx+8,ty+40);ctx.fillText('Click +1 Round',tx+8,ty+54)}

  // BOTTOM: How It Works
  const by=250;
  ctx.fillStyle='rgba(6,6,12,.92)';ctx.beginPath();ctx.roundRect(10,by,730,100,8);ctx.fill();
  ctx.fillStyle='#ffd166';ctx.font='700 11px Fira Code';ctx.fillText('How AdaBoost Works \u2014 5 Simple Steps:',20,by+18);
  const steps=[
    {ic:'\u2696\ufe0f',t:'Equal Weights',d:'Every point starts at w=1/N',c:'#7d7a8c'},
    {ic:'\ud83e\udeb5',t:'Train Stump',d:'Find best single split line',c:'#ffd166'},
    {ic:'\ud83d\udcca',t:'Score Stump',d:'\u03b1 = \u00bdln((1-err)/err)',c:'#a78bfa'},
    {ic:'\u2b06\ufe0f',t:'Re-weight',d:'Wrong pts get bigger weights',c:'#ff6b6b'},
    {ic:'\ud83d\udd01',t:'Repeat!',d:'Next stump targets mistakes',c:'#34d399'}
  ];
  const sw=140;
  steps.forEach((s,i)=>{const sx=15+i*sw;
    ctx.fillStyle='rgba(20,20,35,.9)';ctx.beginPath();ctx.roundRect(sx,by+28,sw-8,62,6);ctx.fill();
    ctx.strokeStyle=s.c+'44';ctx.lineWidth=1;ctx.beginPath();ctx.roundRect(sx,by+28,sw-8,62,6);ctx.stroke();
    ctx.fillStyle=s.c;ctx.font='700 10px Fira Code';ctx.fillText(s.ic+' '+s.t,sx+6,by+44);
    ctx.fillStyle='#7d7a8c';ctx.font='400 8px Fira Code';
    const words2=s.d.split(' ');let line='',ly2=by+58;
    words2.forEach(w2=>{if((line+' '+w2).length>20){ctx.fillText(line,sx+6,ly2);ly2+=10;line=w2}else line=line?line+' '+w2:w2});
    if(line)ctx.fillText(line,sx+6,ly2);
    if(i<4){ctx.fillStyle='#4a475a';ctx.font='14px sans-serif';ctx.fillText('\u2192',sx+sw-12,by+56)}
  });

  // Key Insight
  ctx.fillStyle='rgba(6,6,12,.85)';ctx.beginPath();ctx.roundRect(10,by+108,730,112,8);ctx.fill();
  ctx.fillStyle='#4ecdc4';ctx.font='600 10px Fira Code';ctx.fillText('Key Insight: Weak + Weak + Weak = Strong!',20,by+126);
  ctx.fillStyle='#e4e2df';ctx.font='400 9px Fira Code';
  ctx.fillText('Each stump alone is barely better than random (a "weak learner" \u2014 just one split!).',20,by+144);
  ctx.fillText('But by focusing each new stump on the mistakes of previous ones, the ensemble becomes a "strong learner".',20,by+160);
  ctx.fillText('Final prediction = weighted vote: H(x) = sign(\u03a3 \u03b1\u209chc(x)). More accurate stumps get higher voting power \u03b1.',20,by+176);
  ctx.fillText('Boosting = sequential, focus on mistakes.  Bagging (Random Forest) = parallel, focus on diversity.',20,by+192);

  // Weak -> Strong visual
  if(ns>0){const mX=20,mY=by+206;
    ctx.fillStyle='#7d7a8c';ctx.font='400 9px Fira Code';ctx.fillText('Weak:',mX,mY);
    for(let i=0;i<Math.min(ns,8);i++){
      ctx.fillStyle='#ffd16644';ctx.beginPath();ctx.roundRect(mX+48+i*22,mY-10,18,14,3);ctx.fill();
      ctx.fillStyle='#ffd166';ctx.font='600 7px Fira Code';ctx.fillText('h'+(i+1),mX+51+i*22,mY)}
    if(ns>8){ctx.fillStyle='#7d7a8c';ctx.font='400 8px Fira Code';ctx.fillText('+'+(ns-8),mX+48+8*22+2,mY)}
    ctx.fillStyle='#4a475a';ctx.font='14px sans-serif';ctx.fillText('\u2192',mX+48+Math.min(ns,8)*22+(ns>8?22:4),mY);
    ctx.fillStyle='#34d399';ctx.font='700 10px Fira Code';ctx.fillText('Strong!',mX+48+Math.min(ns,8)*22+(ns>8?40:22),mY)}
}

const ctrl=addControls(el);
const ab1=document.createElement('button');ab1.className='btn';ab1.textContent='\u25b6 +1 Round';ab1.onclick=addStump;
const ab5=document.createElement('button');ab5.className='btn';ab5.textContent='\u23e9 +5 Rounds';ab5.onclick=()=>{for(let i=0;i<5;i++)addStump()};
let autoTmr=null;
const abAuto=document.createElement('button');abAuto.className='btn';abAuto.textContent='\u25b6\ufe0f Auto';
abAuto.onclick=()=>{if(autoTmr){clearInterval(autoTmr);autoTmr=null;abAuto.classList.remove('active')}
  else{autoTmr=setInterval(()=>{addStump();if(round>=20){clearInterval(autoTmr);autoTmr=null;abAuto.classList.remove('active')}},400);abAuto.classList.add('active')}};
const abRst=document.createElement('button');abRst.className='btn';abRst.textContent='\u21bb Reset';
abRst.onclick=()=>{if(autoTmr){clearInterval(autoTmr);autoTmr=null;abAuto.classList.remove('active')}seedPts();draw()};
ctrl.appendChild(ab1);ctrl.appendChild(ab5);ctrl.appendChild(abAuto);ctrl.appendChild(abRst);draw();
})();
</script></body></html>
