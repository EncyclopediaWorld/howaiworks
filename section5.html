<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Section V ‚Äî The Eve of Deep Learning ¬∑ How AI Works</title>
<link rel="stylesheet" href="styles.css">
</head><body>
<div class="progress-bar" style="background:linear-gradient(90deg,var(--a4),var(--a5))"></div>
<button class="back-top" onclick="window.scrollTo({top:0,behavior:'smooth'})">‚Üë</button>
<nav class="topnav"><a href="index.html" class="logo">How AI Works</a><div class="nav-links"><a href="section1.html">I</a><a href="section2.html">II</a><a href="section3.html">III</a><a href="section4.html">IV</a><a href="section5.html" class="active">V</a><a href="section6.html">VI</a><a href="section7.html">VII</a><a href="section8.html">VIII</a></div></nav>
<div class="section-hero"><div class="era-label" style="color:var(--a4)">Section V ¬∑ 2000s</div>
<h1>The Eve of Deep Learning</h1><p>Deep belief nets, autoencoders, gradient boosting, and neural language models set the stage for the deep learning revolution.</p>
<div class="nav-arrows"><a href="section4.html">&larr; Section IV</a><a href="section6.html">Section VI &rarr;</a></div></div>
<div class="models-container">

<!-- ======= DBN ======= -->
<div class="model-card" id="model-dbn"><div class="mc-head"><span class="mc-year" style="color:var(--a4)">2006</span><div class="mc-info">
<h3>Deep Belief Network (DBN) <a href="https://doi.org/10.1162/neco.2006.18.7.1527" target="_blank" class="paper-link">Paper</a></h3>
<p>Hinton's breakthrough ‚Äî train deep networks by stacking Restricted Boltzmann Machines one layer at a time. Each layer learns increasingly abstract features.</p>
<div class="model-lineage">Stacks <a href="section3.html#model-boltzmann">Boltzmann Machine</a> layers with greedy pretraining; this first successful deep network paves the way for <a href="section6.html#model-alexnet">AlexNet</a> and all modern deep learning.</div>
</div></div>
<div class="mc-formula" style="color:var(--a4)">Layer 1: learn edges ‚Üí Layer 2: learn shapes ‚Üí Layer 3: learn objects (greedy pretraining)</div>
<div class="mc-demo" id="demo-dbn"></div></div>

<!-- ======= SPARSE AUTOENCODER ======= -->
<div class="model-card" id="model-sparse-ae"><div class="mc-head"><span class="mc-year" style="color:var(--a4)">2006</span><div class="mc-info">
<h3>Sparse Autoencoder <a href="https://arxiv.org/abs/1312.5663" target="_blank" class="paper-link">Paper</a></h3>
<p>Compress data through a bottleneck, then reconstruct it. Sparsity constraint ensures only a few neurons activate ‚Äî forcing efficient, meaningful features.</p>
<div class="model-lineage">Learns compressed representations like <a href="section5.html#model-dbn">DBN</a> but via reconstruction loss; its encode-decode structure directly leads to <a href="section6.html#model-vae">VAE</a> (adds probabilistic sampling).</div>
</div></div>
<div class="mc-formula" style="color:var(--a4)">Input ‚Üí Encoder (compress) ‚Üí Bottleneck (sparse code) ‚Üí Decoder (reconstruct) ‚Üí Output ‚âà Input</div>
<div class="mc-demo" id="demo-sae"></div></div>

<!-- ======= DENOISING AUTOENCODER ======= -->
<div class="model-card" id="model-dae"><div class="mc-head"><span class="mc-year" style="color:var(--a4)">2008</span><div class="mc-info">
<h3>Denoising Autoencoder <a href="https://doi.org/10.1145/1390156.1390294" target="_blank" class="paper-link">Paper</a></h3>
<p>Corrupt the input with noise, then train the network to reconstruct the CLEAN original. Forces robust features that capture true data structure.</p>
<div class="model-lineage">Extends <a href="section5.html#model-sparse-ae">Sparse Autoencoder</a> with noise-based regularization; the "denoise to learn" principle directly inspires <a href="section8.html#model-diffusion">Diffusion Models</a>.</div>
</div></div>
<div class="mc-formula" style="color:var(--a4)">Clean x ‚Üí Add noise ‚Üí xÃÉ ‚Üí Encoder ‚Üí Decoder ‚Üí xÃÇ ‚âà x (not xÃÉ!) ‚Äî learn to denoise</div>
<div class="mc-demo" id="demo-dae"></div></div>

<!-- ======= GBDT ======= -->
<div class="model-card" id="model-gbdt"><div class="mc-head"><span class="mc-year" style="color:var(--a4)">2001</span><div class="mc-info">
<h3>GBDT (Gradient Boosted Decision Trees) <a href="https://doi.org/10.1214/aos/1013203451" target="_blank" class="paper-link">Paper</a></h3>
<p>Friedman's gradient boosting ‚Äî each new tree fits the RESIDUAL errors of the previous ensemble. Sequentially reduces loss by correcting current mistakes.</p>
<div class="model-lineage">Replaces <a href="section4.html#model-adaboost">AdaBoost</a>'s sample reweighting with gradient-based residual fitting on <a href="section3.html#model-dtree">Decision Trees</a>; optimized into <a href="section7.html#model-xgboost">XGBoost</a>.</div>
</div></div>
<div class="mc-formula" style="color:var(--a4)">F_m(x) = F_{m-1}(x) + Œ∑ ¬∑ h_m(x) where h_m fits the residuals r = y - F_{m-1}(x)</div>
<div class="mc-demo" id="demo-gbdt"></div></div>

<!-- ======= NNLM ======= -->
<div class="model-card" id="model-nnlm"><div class="mc-head"><span class="mc-year" style="color:var(--a4)">2003</span><div class="mc-info">
<h3>NNLM (Neural Network Language Model) <a href="https://jmlr.org/papers/v3/bengio03a.html" target="_blank" class="paper-link">Paper</a></h3>
<p>Bengio's breakthrough ‚Äî predict the next word using a neural network over word embeddings. Each word gets a learned vector representation.</p>
<div class="model-lineage">First neural approach to language modeling using <a href="section3.html#model-backprop">Backpropagation</a>; its word embeddings lead to <a href="section6.html#model-word2vec">Word2Vec</a> and its next-word prediction paradigm leads to <a href="section7.html#model-gpt1">GPT</a>.</div>
</div></div>
<div class="mc-formula" style="color:var(--a4)">P(w‚Çú | w‚Çú‚Çã‚ÇÅ, w‚Çú‚Çã‚ÇÇ, ...) = softmax(W ¬∑ tanh(C ¬∑ [e(w‚Çú‚Çã‚ÇÅ); e(w‚Çú‚Çã‚ÇÇ); ...]))</div>
<div class="mc-demo" id="demo-nnlm"></div></div>

</div>
<footer><a href="section4.html">&larr; Section IV</a> &middot; <a href="section6.html">Section VI: Deep Learning Explosion &rarr;</a></footer>
<script src="shared.js"></script>
<script>
// ===== DEEP BELIEF NETWORK =====
(function(){const el=$('demo-dbn'),[c,ctx]=createCanvas(el,750,360);
addHint(el,'Press "Train Layer" to pretrain each RBM layer bottom-up. Watch features become progressively more abstract!');
const layers=[
{name:'Input',n:8,neurons:[],desc:'Raw pixels'},
{name:'Layer 1 (RBM-1)',n:6,neurons:[],trained:false,desc:'Edges & strokes'},
{name:'Layer 2 (RBM-2)',n:4,neurons:[],trained:false,desc:'Shapes & parts'},
{name:'Layer 3 (RBM-3)',n:3,neurons:[],trained:false,desc:'Objects & concepts'}];
let currentLayer=0,trainAnim=0;
layers.forEach(l=>{l.neurons=Array(l.n).fill(0).map(()=>rand(0,.3))});
function trainCurrentLayer(){if(currentLayer>=layers.length-1)return;
currentLayer++;let L=layers[currentLayer];L.trained=true;
let below=layers[currentLayer-1].neurons;
L.neurons=L.neurons.map((v,i)=>{let sum=below.reduce((a,b,j)=>a+b*Math.sin((i+1)*(j+1)),0)/below.length;
return sigmoid(sum*3+rand(-.2,.2))});
layers[currentLayer-1].neurons=layers[currentLayer-1].neurons.map((v,i)=>sigmoid(v*2+Math.sin(currentLayer*i)*0.3));
trainAnim=20;draw()}
function draw(){ctx.clearRect(0,0,750,360);
let lw=175,startX=20;
layers.forEach((L,li)=>{let x=startX+li*lw,y=28;
let isTraining=li===currentLayer&&trainAnim>0;
let isTrained=L.trained||li===0;
ctx.fillStyle=isTrained?'rgba(167,139,250,.06)':'rgba(20,20,35,.5)';
ctx.beginPath();ctx.roundRect(x,y,lw-15,250,10);ctx.fill();
ctx.strokeStyle=isTraining?'#ffd166':isTrained?'#a78bfa44':'#1e1e32';
ctx.lineWidth=isTraining?2:1;ctx.beginPath();ctx.roundRect(x,y,lw-15,250,10);ctx.stroke();
ctx.fillStyle=isTrained?'#a78bfa':'#4a475a';ctx.font='600 9px Fira Code';ctx.fillText(L.name,x+8,y+18);
ctx.fillStyle=isTrained?'#7d7a8c':'#333';ctx.font='400 8px Fira Code';ctx.fillText(L.desc,x+8,y+32);
L.neurons.forEach((v,ni)=>{let ny=y+50+ni*28,nr=11;
ctx.save();if(v>.5){ctx.shadowColor='#a78bfa';ctx.shadowBlur=v*14}
ctx.beginPath();ctx.arc(x+lw/2-7,ny,nr,0,TAU);
ctx.fillStyle=isTrained?`rgba(167,139,250,${Math.max(v,.05)})`:`rgba(60,60,80,${Math.max(v,.05)})`;ctx.fill();
ctx.strokeStyle=isTrained?'#a78bfa66':'#333';ctx.lineWidth=1;ctx.stroke();ctx.restore();
ctx.fillStyle=v>.5?'#e4e2df':'#4a475a';ctx.font='500 8px Fira Code';ctx.textAlign='center';
ctx.fillText(v.toFixed(2),x+lw/2-7,ny+3);ctx.textAlign='left'});
if(li<layers.length-1){ctx.fillStyle=isTrained?'#a78bfa44':'#1e1e32';ctx.font='16px sans-serif';ctx.fillText('‚Üí',x+lw-12,155)}
if(isTraining){ctx.fillStyle='#ffd166';ctx.font='600 8px Fira Code';ctx.fillText('‚ö° Training RBM...',x+8,y+245)}
else if(li>0&&L.trained){ctx.fillStyle='#34d399';ctx.font='600 8px Fira Code';ctx.fillText('‚úì Pretrained',x+8,y+245)}});
ctx.fillStyle='rgba(6,6,12,.88)';ctx.beginPath();ctx.roundRect(15,290,720,62,10);ctx.fill();
ctx.fillStyle='#a78bfa';ctx.font='600 10px Fira Code';
ctx.fillText('Greedy Layer-wise Pretraining (Hinton 2006):',25,308);
ctx.fillStyle='#e4e2df';ctx.font='400 9px Fira Code';
ctx.fillText('Step '+currentLayer+'/3: '+(currentLayer===0?'Start from raw input. Press "Train Layer" to pretrain Layer 1.':
currentLayer===1?'Layer 1 learned edge features. Now train Layer 2 on Layer 1\'s output.':
currentLayer===2?'Layer 2 learned shapes. Train Layer 3 (most abstract).':
'All layers pretrained! Each learns progressively more abstract features.'),25,326);
ctx.fillStyle='#7d7a8c';ctx.font='400 8px Fira Code';
ctx.fillText('Key: train one RBM layer at a time (bottom-up). This was the first way to successfully train deep networks!',25,345);
if(trainAnim>0){trainAnim--;requestAnimationFrame(draw)}}
layers[0].neurons=layers[0].neurons.map(()=>rand(.2,.95));
const ctrl=addControls(el);
const tb=document.createElement('button');tb.className='btn';tb.textContent='‚ö° Train Next Layer';tb.onclick=trainCurrentLayer;
const rst=document.createElement('button');rst.className='btn';rst.textContent='‚Üª Reset';
rst.onclick=()=>{currentLayer=0;layers.forEach((l,i)=>{l.trained=false;l.neurons=Array(l.n).fill(0).map(()=>rand(0,.3))});layers[0].neurons=layers[0].neurons.map(()=>rand(.2,.95));draw()};
ctrl.appendChild(tb);ctrl.appendChild(rst);draw()})();

// ===== SPARSE AUTOENCODER ‚Äî Visual Pixel-Grid Demo =====
(function(){const el=$('demo-sae'),[c,ctx]=createCanvas(el,750,342);
addHint(el,'Pick a shape, then drag the Sparsity slider. Watch neurons turn OFF and features vanish from the reconstruction!');

const G=6, NH=8, NN=G*G;
// Each hidden neuron is a spatial feature detector for a specific region of the 6x6 grid.
// This means reconstruction ACTUALLY WORKS and sparsity visibly removes features.
const featureNames=['Top row','Bottom row','Left col','Right col','Center +','Diag \\\\','Mid row','Mid col'];
const featureMasks=[ // each is a 36-element weight mask
  [1,1,1,1,1,1, .2,0,0,0,0,.2, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],  // top row
  [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, .2,0,0,0,0,.2, 1,1,1,1,1,1],  // bottom row
  [1,.2,0,0,0,0, 1,.2,0,0,0,0, 1,.2,0,0,0,0, 1,.2,0,0,0,0, 1,.2,0,0,0,0, 1,.2,0,0,0,0],  // left col
  [0,0,0,0,.2,1, 0,0,0,0,.2,1, 0,0,0,0,.2,1, 0,0,0,0,.2,1, 0,0,0,0,.2,1, 0,0,0,0,.2,1],  // right col
  [0,0,.3,0,0,0, 0,0,.3,0,0,0, .3,.3,1,.3,.3,0, 0,0,.3,0,0,0, 0,0,.3,0,0,0, 0,0,.3,0,0,0], // center cross
  [1,0,0,0,0,0, 0,1,0,0,0,0, 0,0,1,0,0,0, 0,0,0,1,0,0, 0,0,0,0,1,0, 0,0,0,0,0,1],      // main diagonal
  [0,0,0,0,0,0, 0,0,0,0,0,0, .3,.3,.3,.3,.3,0, .3,.3,.3,.3,.3,0, 0,0,0,0,0,0, 0,0,0,0,0,0], // mid rows
  [0,0,.3,0,0,0, 0,0,.3,0,0,0, 0,0,.5,0,0,0, 0,0,.5,0,0,0, 0,0,.3,0,0,0, 0,0,.3,0,0,0]  // mid col
];
const featureColors=['#ff6b6b','#38bdf8','#ffd166','#4ecdc4','#a78bfa','#f472b6','#34d399','#fb923c'];

const patterns=[
  {name:'X',grid:[1,0,0,0,1,0, 0,1,0,1,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,1,0,1,0,0, 1,0,0,0,1,0]},
  {name:'O',grid:[0,1,1,1,0,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,1,1,1,0,0]},
  {name:'T',grid:[1,1,1,1,1,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0]},
  {name:'L',grid:[1,0,0,0,0,0, 1,0,0,0,0,0, 1,0,0,0,0,0, 1,0,0,0,0,0, 1,0,0,0,0,0, 1,1,1,1,1,0]},
  {name:'H',grid:[1,0,0,0,1,0, 1,0,0,0,1,0, 1,1,1,1,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0]},
  {name:'/',grid:[0,0,0,0,0,1, 0,0,0,0,1,0, 0,0,0,1,0,0, 0,0,1,0,0,0, 0,1,0,0,0,0, 1,0,0,0,0,0]}
];
let selected=0, sparsity=0.0;

// Encode: dot product with each feature mask
function encode(input){
  const h=new Float32Array(NH);
  for(let j=0;j<NH;j++){let s=0;for(let i=0;i<NN;i++) s+=input[i]*featureMasks[j][i];
    h[j]=s/featureMasks[j].reduce((a,v)=>a+v,0.01);} // normalize by mask energy
  return h;
}
// Sparsity: keep top-k by activation
function applySparse(h){
  const k=Math.max(1,Math.round(NH*(1-sparsity)));
  const idx=[...h].map((v,i)=>({v,i})).sort((a,b)=>b.v-a.v);
  const out=new Float32Array(NH),act=new Set();
  for(let i=0;i<k;i++){out[idx[i].i]=h[idx[i].i];act.add(idx[i].i);}
  return{sparse:out,act};
}
// Decode: weighted sum of feature masks
function decode(sp){
  const out=new Float32Array(NN);
  for(let j=0;j<NH;j++){if(sp[j]<0.01)continue;
    for(let i=0;i<NN;i++) out[i]+=sp[j]*featureMasks[j][i];}
  // Normalize to 0-1
  let mx=0;for(let i=0;i<NN;i++) if(out[i]>mx) mx=out[i];
  if(mx>0.01) for(let i=0;i<NN;i++) out[i]/=mx;
  return out;
}

function drawGrid(ox,oy,sz,data,color,binary){
  ctx.fillStyle='#08081a';ctx.beginPath();ctx.roundRect(ox-2,oy-2,G*sz+4,G*sz+4,4);ctx.fill();
  for(let r=0;r<G;r++) for(let ci=0;ci<G;ci++){
    const v=data[r*G+ci];
    if(binary) ctx.fillStyle=v>0.4?color:'#111125';
    else ctx.fillStyle=color.slice(0,7)+(Math.round(clamp(v,0.04,1)*230).toString(16).padStart(2,'0'));
    ctx.fillRect(ox+ci*sz,oy+r*sz,sz-1,sz-1);
  }
}

function draw(){
  ctx.clearRect(0,0,750,342);
  const p=patterns[selected];
  const rawH=encode(p.grid),{sparse,act}=applySparse(rawH),decoded=decode(sparse);
  const activeCount=act.size;

  // === TOP: Pattern selector buttons ===
  patterns.forEach((pp,i)=>{
    const bw=80,bh=56,cols=6,x=14+i*(bw+6),y=4;
    ctx.fillStyle=i===selected?'rgba(167,139,250,.12)':'#0c0c16';
    ctx.beginPath();ctx.roundRect(x,y,bw,bh,6);ctx.fill();
    ctx.strokeStyle=i===selected?'#a78bfa':'#1e1e32';ctx.lineWidth=i===selected?2:1;
    ctx.beginPath();ctx.roundRect(x,y,bw,bh,6);ctx.stroke();
    // Mini preview grid
    const ms=6;
    for(let r=0;r<G;r++) for(let ci=0;ci<G;ci++){
      ctx.fillStyle=pp.grid[r*G+ci]>0.4?(i===selected?'#a78bfa':'#4a475a'):'transparent';
      ctx.fillRect(x+12+ci*ms,y+4+r*ms,ms-1,ms-1);
    }
    ctx.fillStyle=i===selected?'#e4e2df':'#4a475a';ctx.font='600 10px Fira Code';
    ctx.textAlign='center';ctx.fillText('"'+pp.name+'"',x+bw/2,y+bh-6);ctx.textAlign='left';
  });

  // === MAIN FLOW: Input ‚Üí Bottleneck ‚Üí Output (row at y=70) ===
  const flowY=70, cellSz=20;

  // --- INPUT ---
  const inX=16;
  ctx.fillStyle='#38bdf8';ctx.font='700 11px Fira Code';ctx.fillText('Input (6\u00d76)',inX,flowY+10);
  drawGrid(inX,flowY+16,cellSz,p.grid,'#38bdf8',true);

  // --- ARROW 1 ---
  ctx.fillStyle='#4a475a';ctx.font='bold 20px sans-serif';ctx.fillText('\u2192',inX+G*cellSz+8,flowY+G*cellSz/2+20);
  ctx.fillStyle='#7d7a8c';ctx.font='500 9px Fira Code';ctx.fillText('Encode',inX+G*cellSz+4,flowY+10);

  // --- BOTTLENECK (centered, with feature mini-grids) ---
  const bnX=185, bnW=350, neuronW=bnW/NH-2;
  ctx.fillStyle='#a78bfa';ctx.font='700 11px Fira Code';
  ctx.fillText('Sparse Bottleneck  ('+activeCount+'/'+NH+' active)',bnX,flowY+10);

  for(let j=0;j<NH;j++){
    const nx=bnX+j*(neuronW+2), ny=flowY+16;
    const isAct=act.has(j), val=sparse[j], rawVal=rawH[j];
    const col=featureColors[j];

    // Neuron card
    ctx.fillStyle=isAct?'rgba(20,20,40,.95)':'rgba(12,12,20,.95)';
    ctx.beginPath();ctx.roundRect(nx,ny,neuronW,G*cellSz+38,5);ctx.fill();
    ctx.strokeStyle=isAct?col+'88':'#222';ctx.lineWidth=isAct?1.5:0.5;
    ctx.beginPath();ctx.roundRect(nx,ny,neuronW,G*cellSz+38,5);ctx.stroke();

    // Feature detector mini-grid (what this neuron looks for)
    const ms=Math.floor((neuronW-4)/G);
    for(let r=0;r<G;r++) for(let ci=0;ci<G;ci++){
      const w=featureMasks[j][r*G+ci];
      if(w>0.05){
        const a=isAct?clamp(w,0.2,1):clamp(w*0.2,0.05,0.3);
        ctx.fillStyle=col+(Math.round(a*220).toString(16).padStart(2,'0'));
      } else ctx.fillStyle='#0a0a18';
      ctx.fillRect(nx+2+ci*ms,ny+2+r*ms,ms-1,ms-1);
    }

    // Activation bar
    const barY=ny+G*ms+5, barH=8;
    ctx.fillStyle='#111120';ctx.beginPath();ctx.roundRect(nx+2,barY,neuronW-4,barH,2);ctx.fill();
    if(isAct){
      ctx.fillStyle=col+'aa';ctx.beginPath();ctx.roundRect(nx+2,barY,Math.max((neuronW-4)*val,3),barH,2);ctx.fill();
    }

    // Label
    ctx.fillStyle=isAct?'#e4e2df':'#444';ctx.font=(isAct?'600':'400')+' 7px Fira Code';
    ctx.textAlign='center';ctx.fillText(isAct?featureNames[j]:'OFF',nx+neuronW/2,barY+barH+10);
    // Active/suppressed marker
    if(!isAct){
      ctx.strokeStyle='#ff6b6b66';ctx.lineWidth=2;
      ctx.beginPath();ctx.moveTo(nx+4,ny+4);ctx.lineTo(nx+neuronW-4,ny+G*ms-2);ctx.stroke();
      ctx.beginPath();ctx.moveTo(nx+neuronW-4,ny+4);ctx.lineTo(nx+4,ny+G*ms-2);ctx.stroke();
    }
    ctx.textAlign='left';
  }

  // --- ARROW 2 ---
  const arrX2=bnX+bnW+6;
  ctx.fillStyle='#4a475a';ctx.font='bold 20px sans-serif';ctx.fillText('\u2192',arrX2,flowY+G*cellSz/2+20);
  ctx.fillStyle='#7d7a8c';ctx.font='500 9px Fira Code';ctx.fillText('Decode',arrX2-2,flowY+10);

  // --- OUTPUT ---
  const outX=arrX2+28;
  ctx.fillStyle='#4ecdc4';ctx.font='700 11px Fira Code';ctx.fillText('Reconstr.',outX,flowY+10);
  drawGrid(outX,flowY+16,cellSz,decoded,'#4ecdc4',false);

  // --- ERROR OVERLAY under output ---
  let totalErr=0;
  for(let i=0;i<NN;i++) totalErr+=(p.grid[i]-decoded[i])*(p.grid[i]-decoded[i]);
  const mse=totalErr/NN;
  const quality=clamp(1-mse*3,0,1);

  // Quality badge next to output grid
  const qY=flowY+16+G*cellSz+6;
  ctx.fillStyle='#7d7a8c';ctx.font='500 9px Fira Code';ctx.fillText('Quality',outX,qY+10);
  ctx.fillStyle='#111120';ctx.beginPath();ctx.roundRect(outX+46,qY+2,G*cellSz-46,12,3);ctx.fill();
  const qg=ctx.createLinearGradient(outX+46,0,outX+G*cellSz,0);
  qg.addColorStop(0,'#ff6b6b');qg.addColorStop(.5,'#ffd166');qg.addColorStop(1,'#34d399');
  ctx.fillStyle=qg;ctx.beginPath();ctx.roundRect(outX+46,qY+2,(G*cellSz-46)*quality,12,3);ctx.fill();
  ctx.fillStyle='#e4e2df';ctx.font='bold 8px Fira Code';
  ctx.fillText((quality*100).toFixed(0)+'%',outX+G*cellSz+4,qY+12);

  // === BOTTOM: Explanation ===
  const exY=flowY+G*cellSz+48;
  ctx.fillStyle='rgba(6,6,12,.92)';ctx.beginPath();ctx.roundRect(12,exY,726,100,8);ctx.fill();

  ctx.fillStyle='#ffd166';ctx.font='700 10px Fira Code';
  ctx.fillText('How It Works:',22,exY+16);
  ctx.fillStyle='#e4e2df';ctx.font='400 9px Fira Code';
  ctx.fillText('Each bottleneck neuron is a "feature detector" \u2014 it looks for a specific pattern (shown in its mini-grid above).',22,exY+32);
  ctx.fillText('The encoder measures how much each feature is present in the input. The decoder rebuilds using only active features.',22,exY+48);
  ctx.fillStyle='#a78bfa';ctx.font='600 9px Fira Code';
  ctx.fillText('Sparsity constraint forces most neurons OFF \u2192 only the most important features survive!',22,exY+64);
  ctx.fillStyle='#7d7a8c';ctx.font='400 9px Fira Code';
  ctx.fillText('Try it: slide Sparsity right \u2192 watch features disappear one by one \u2192 reconstruction degrades gracefully.',22,exY+80);
  ctx.fillText('Active: '+activeCount+'/'+NH+' | MSE: '+mse.toFixed(4)+' | Compression: 36 pixels \u2192 '+activeCount+' features ('+(activeCount/NN*100).toFixed(0)+'%)',22,exY+96);
}

c.onclick=e=>{const r=c.getBoundingClientRect(),mx=(e.clientX-r.left)*750/r.width,my=(e.clientY-r.top)*342/r.height;
  patterns.forEach((pp,i)=>{const bw=80,x=14+i*(bw+6),y=4;if(mx>=x&&mx<=x+bw&&my>=y&&my<=y+56){selected=i;draw();}});};
const ctrl=addControls(el);
const slbl=document.createElement('label');slbl.textContent='Sparsity';slbl.style.cssText='color:#a78bfa;font:600 10px Fira Code;margin-right:4px';
const slider=document.createElement('input');slider.type='range';slider.min='0';slider.max='88';slider.value='0';slider.style.cssText='width:120px;vertical-align:middle';
const sval=document.createElement('span');sval.className='btn';sval.style.cssText='min-width:70px;text-align:center;font-size:10px';
sval.textContent=NH+'/'+NH+' active';
slider.oninput=e=>{sparsity=e.target.value/100;const k=Math.max(1,Math.round(NH*(1-sparsity)));sval.textContent=k+'/'+NH+' active';draw();};
ctrl.appendChild(slbl);ctrl.appendChild(slider);ctrl.appendChild(sval);
const rst=document.createElement('button');rst.className='btn';rst.textContent='\u21bb Reset';
rst.onclick=()=>{selected=0;sparsity=0;slider.value='0';sval.textContent=NH+'/'+NH+' active';draw();};ctrl.appendChild(rst);
draw();})();


// ===== DENOISING AUTOENCODER =====
(function(){const el=$('demo-dae'),[c,ctx]=createCanvas(el,750,300);
addHint(el,'Click "Add Noise" to corrupt the signal. The autoencoder learns to reconstruct the CLEAN original from noisy input!');
let clean=Array(24).fill(0).map((_,i)=>Math.sin(i*.3)*.4+.5);
let noisy=[...clean],decoded=[...clean],noiseLevel=.25,trained=false;
function addNoise(){noisy=clean.map(v=>clamp(v+rand(-noiseLevel,noiseLevel),0,1))}
function denoise(){decoded=noisy.map((v,i)=>{let neighbors=[noisy[i-1]||v,v,noisy[i+1]||v];
return trained?clamp(neighbors.reduce((a,b)=>a+b,0)/3*.8+clean[i]*.2,0,1):v});trained=true}
function draw(){ctx.clearRect(0,0,750,300);
let bw=28,gap=3,stages=[
{label:'Clean Original',vals:clean,c:'#4ecdc4',x:15},
{label:'Noisy Input (corrupted)',vals:noisy,c:'#ff6b6b',x:265},
{label:'Reconstructed (denoised)',vals:decoded,c:'#a78bfa',x:515}];
stages.forEach(s=>{ctx.fillStyle=s.c;ctx.font='600 10px Fira Code';ctx.fillText(s.label,s.x,18);
// Bar chart
s.vals.forEach((v,i)=>{let x=s.x+(i%12)*(bw/2+gap),y=i<12?30:145;
let barH=100*v;
ctx.fillStyle='#111120';ctx.fillRect(x,y,bw/2,100);
ctx.fillStyle=s.c+'88';ctx.fillRect(x,y+100-barH,bw/2,barH)});
// Wave overlay
ctx.strokeStyle=s.c;ctx.lineWidth=1.5;ctx.beginPath();
s.vals.forEach((v,i)=>{let x=s.x+(i%12)*(bw/2+gap)+bw/4,y=i<12?30:145;
let py=y+100-100*v;i%12===0?ctx.moveTo(x,py):ctx.lineTo(x,py)});ctx.stroke()});
ctx.fillStyle='#4a475a';ctx.font='600 12px sans-serif';ctx.fillText('‚Üí corrupt ‚Üí',195,90);ctx.fillText('‚Üí denoise ‚Üí',445,90);
// Error
let mseN=clean.reduce((a,v,i)=>a+(v-noisy[i])**2,0)/clean.length;
let mseR=clean.reduce((a,v,i)=>a+(v-decoded[i])**2,0)/clean.length;
ctx.fillStyle='rgba(6,6,12,.88)';ctx.beginPath();ctx.roundRect(15,260,720,32,8);ctx.fill();
ctx.fillStyle='#ff6b6b';ctx.font='500 9px Fira Code';ctx.fillText('Noise MSE: '+mseN.toFixed(4),25,278);
ctx.fillStyle='#a78bfa';ctx.fillText('After denoise: '+mseR.toFixed(4),200,278);
ctx.fillStyle='#ffd166';ctx.fillText(trained?'Improvement: '+(((mseN-mseR)/mseN)*100).toFixed(0)+'% error reduced!':'Press Add Noise then Denoise',400,278)}
const ctrl=addControls(el);
ctrl.innerHTML='<label>Noise</label><input type="range" min="5" max="50" value="25" id="dnl"><span id="dnlv" class="btn" style="min-width:32px;text-align:center">0.25</span>';
$('dnl').oninput=e=>{noiseLevel=e.target.value/100;$('dnlv').textContent=noiseLevel.toFixed(2)};
const nb=document.createElement('button');nb.className='btn';nb.textContent='üîä Add Noise';nb.onclick=()=>{addNoise();trained=false;decoded=[...noisy];draw()};
const db=document.createElement('button');db.className='btn';db.textContent='‚ú® Denoise';db.onclick=()=>{denoise();draw()};
const rst=document.createElement('button');rst.className='btn';rst.textContent='‚Üª Reset';
rst.onclick=()=>{noisy=[...clean];decoded=[...clean];trained=false;draw()};
ctrl.appendChild(nb);ctrl.appendChild(db);ctrl.appendChild(rst);draw()})();

// ===== GBDT =====
(function(){const el=$('demo-gbdt'),[c,ctx]=createCanvas(el,750,340);
addHint(el,'Each tree fits the RESIDUALS (red gaps) of the current prediction. Watch the green line approach the blue targets!');
let data=[];for(let i=0;i<30;i++){let x=20+i*23;data.push({x,y:150+Math.sin(i*.3)*80+rand(-15,15)})}
let trees=[],predictions=data.map(()=>150),lr4=0.3;
function addTree(){let residuals=data.map((d,i)=>d.y-predictions[i]);
let bestScore=Infinity,bestVal=null;
for(let s=40;s<710;s+=15){let left=residuals.filter((_,i)=>data[i].x<=s);
let right=residuals.filter((_,i)=>data[i].x>s);
if(left.length<2||right.length<2)continue;
let lm=left.reduce((a,b)=>a+b,0)/left.length;let rm=right.reduce((a,b)=>a+b,0)/right.length;
let score=left.reduce((a,v)=>a+(v-lm)**2,0)+right.reduce((a,v)=>a+(v-rm)**2,0);
if(score<bestScore){bestScore=score;bestVal={split:s,lm,rm}}}
if(!bestVal)return;trees.push(bestVal);
predictions=predictions.map((p,i)=>p+lr4*(data[i].x<=bestVal.split?bestVal.lm:bestVal.rm));draw()}
function draw(){ctx.clearRect(0,0,750,340);
for(let y=0;y<300;y+=50){ctx.strokeStyle='#1a1a2a';ctx.beginPath();ctx.moveTo(20,y);ctx.lineTo(730,y);ctx.stroke()}
// Target points
data.forEach(d=>{ctx.save();ctx.shadowColor='#38bdf8';ctx.shadowBlur=4;
ctx.beginPath();ctx.arc(d.x,d.y,4,0,TAU);ctx.fillStyle='#38bdf8';ctx.fill();ctx.restore()});
// Prediction line
if(trees.length>0){ctx.save();ctx.shadowColor='#34d399';ctx.shadowBlur=5;
ctx.strokeStyle='#34d399';ctx.lineWidth=2.5;ctx.beginPath();
data.forEach((d,i)=>{i?ctx.lineTo(d.x,predictions[i]):ctx.moveTo(d.x,predictions[i])});ctx.stroke();ctx.restore();
// Residuals
data.forEach((d,i)=>{let r=d.y-predictions[i];if(Math.abs(r)>3){
ctx.strokeStyle='rgba(255,107,107,.4)';ctx.lineWidth=1;ctx.beginPath();ctx.moveTo(d.x,predictions[i]);ctx.lineTo(d.x,d.y);ctx.stroke()}})}
else{ctx.strokeStyle='#34d39966';ctx.lineWidth=2;ctx.setLineDash([4,4]);
ctx.beginPath();ctx.moveTo(20,150);ctx.lineTo(730,150);ctx.stroke();ctx.setLineDash([])}
// Tree splits
trees.forEach((t,i)=>{ctx.strokeStyle=`rgba(255,209,102,${.08+.04*Math.min(i,8)})`;ctx.lineWidth=1;ctx.setLineDash([3,3]);
ctx.beginPath();ctx.moveTo(t.split,0);ctx.lineTo(t.split,300);ctx.stroke();ctx.setLineDash([])});
// Info
let mse=data.reduce((a,d,i)=>a+(d.y-predictions[i])**2,0)/data.length;
ctx.fillStyle='rgba(6,6,12,.88)';ctx.beginPath();ctx.roundRect(8,8,260,48,8);ctx.fill();
ctx.fillStyle='#ffd166';ctx.font='600 11px Fira Code';ctx.fillText('Trees: '+trees.length+' | MSE: '+mse.toFixed(1),18,28);
ctx.fillStyle='#7d7a8c';ctx.font='400 9px Fira Code';ctx.fillText('lr='+lr4+' | Blue=target Green=prediction',18,46);
// Bottom
ctx.fillStyle='rgba(6,6,12,.85)';ctx.beginPath();ctx.roundRect(15,300,720,35,8);ctx.fill();
ctx.fillStyle='#ff6b6b';ctx.font='500 9px Fira Code';
ctx.fillText('Each tree fits residuals (red gaps). New prediction = old + lr √ó tree(x). Residuals shrink each round!',25,320);
ctx.fillStyle='#7d7a8c';ctx.fillText('Unlike Random Forest (parallel), GBDT builds trees sequentially.',25,334)}
const ctrl=addControls(el);
const ab2=document.createElement('button');ab2.className='btn';ab2.textContent='üå≥ +1 Tree';ab2.onclick=addTree;
const a5=document.createElement('button');a5.className='btn';a5.textContent='üå≤ +5 Trees';a5.onclick=()=>{for(let i=0;i<5;i++)addTree()};
let tmr=null;const auto=document.createElement('button');auto.className='btn';auto.textContent='‚è© Auto';
auto.onclick=()=>{if(tmr){clearInterval(tmr);tmr=null;auto.classList.remove('active')}else{tmr=setInterval(()=>{addTree();if(trees.length>30){clearInterval(tmr);tmr=null;auto.classList.remove('active')}},200);auto.classList.add('active')}};
const rst=document.createElement('button');rst.className='btn';rst.textContent='‚Üª Reset';
rst.onclick=()=>{trees=[];predictions=data.map(()=>150);if(tmr){clearInterval(tmr);tmr=null;auto.classList.remove('active')}draw()};
ctrl.appendChild(ab2);ctrl.appendChild(a5);ctrl.appendChild(auto);ctrl.appendChild(rst);draw()})();

// ===== NNLM ‚Äî Next word prediction =====
(function(){const el=$('demo-nnlm'),[c,ctx]=createCanvas(el,750,320);
addHint(el,'Click a context (2 words). The neural network predicts the next word using learned word embeddings.');
const vocab=['the','cat','sat','on','mat','dog','ran','in','park','a','big','small','red','blue','house'];
const contexts=[
{words:['the','cat'],top:[{w:'sat',p:.45},{w:'ran',p:.3},{w:'is',p:.15}]},
{words:['cat','sat'],top:[{w:'on',p:.55},{w:'in',p:.25},{w:'down',p:.12}]},
{words:['sat','on'],top:[{w:'the',p:.5},{w:'a',p:.3},{w:'my',p:.12}]},
{words:['the','dog'],top:[{w:'ran',p:.4},{w:'sat',p:.25},{w:'is',p:.2}]},
{words:['dog','ran'],top:[{w:'in',p:.45},{w:'to',p:.3},{w:'fast',p:.15}]},
{words:['big','red'],top:[{w:'house',p:.4},{w:'car',p:.3},{w:'dog',p:.15}]},
{words:['a','small'],top:[{w:'cat',p:.35},{w:'dog',p:.3},{w:'house',p:.2}]},
{words:['in','the'],top:[{w:'park',p:.4},{w:'house',p:.3},{w:'mat',p:.15}]}];
let selected=0;
const embeddings={};
vocab.forEach((w,i)=>{embeddings[w]=[Math.sin(i*1.2)*80+200,Math.cos(i*.8)*60+120,Math.sin(i*2.1)*40]});
function draw(){ctx.clearRect(0,0,750,320);let ctx2=contexts[selected];
// Context buttons
ctx.fillStyle='#ffd166';ctx.font='600 10px Fira Code';ctx.fillText('Select context (2 previous words):',15,16);
contexts.forEach((cc,i)=>{let x=15+(i%4)*183,y=24+Math.floor(i/4)*32;
ctx.fillStyle=i===selected?'rgba(167,139,250,.12)':'#0c0c16';ctx.beginPath();ctx.roundRect(x,y,176,26,5);ctx.fill();
ctx.strokeStyle=i===selected?'#a78bfa':'#1e1e32';ctx.lineWidth=i===selected?2:1;
ctx.beginPath();ctx.roundRect(x,y,176,26,5);ctx.stroke();
ctx.fillStyle=i===selected?'#e4e2df':'#4a475a';ctx.font='500 10px Fira Code';
ctx.fillText('"'+cc.words[0]+' '+cc.words[1]+' ___"',x+8,y+17)});
let ay=95;
// Word embeddings
ctx.fillStyle='#38bdf8';ctx.font='600 10px Fira Code';ctx.fillText('1. Embeddings',15,ay);
ctx2.words.forEach((w,i)=>{let x=15,y=ay+8+i*42;
ctx.fillStyle='rgba(56,189,248,.08)';ctx.beginPath();ctx.roundRect(x,y,125,36,6);ctx.fill();
ctx.strokeStyle='#38bdf8';ctx.lineWidth=1;ctx.beginPath();ctx.roundRect(x,y,125,36,6);ctx.stroke();
ctx.fillStyle='#38bdf8';ctx.font='600 11px Fira Code';ctx.fillText('"'+w+'"',x+8,y+16);
let emb=embeddings[w]||[0,0,0];ctx.fillStyle='#7d7a8c';ctx.font='400 8px Fira Code';
ctx.fillText('['+emb.map(v=>v.toFixed(0)).join(', ')+']',x+8,y+30)});
// Hidden layer
let hx=185;ctx.fillStyle='#a78bfa';ctx.font='600 10px Fira Code';ctx.fillText('2. Hidden',hx,ay);
ctx.fillStyle='rgba(167,139,250,.05)';ctx.beginPath();ctx.roundRect(hx,ay+8,95,76,8);ctx.fill();
ctx.strokeStyle='#a78bfa';ctx.lineWidth=1;ctx.beginPath();ctx.roundRect(hx,ay+8,95,76,8);ctx.stroke();
ctx.fillStyle='#a78bfa';ctx.font='400 9px Fira Code';ctx.fillText('tanh(W√ó',hx+8,ay+35);ctx.fillText('[e‚ÇÅ;e‚ÇÇ]+b)',hx+8,ay+50);
for(let i=0;i<4;i++){ctx.beginPath();ctx.arc(hx+75,ay+20+i*16,5,0,TAU);ctx.fillStyle='#a78bfa44';ctx.fill();ctx.strokeStyle='#a78bfa';ctx.stroke()}
// Softmax + predictions
let sx=320;ctx.fillStyle='#4ecdc4';ctx.font='600 10px Fira Code';ctx.fillText('3. Softmax ‚Üí P(next)',sx,ay);
ctx.fillStyle='rgba(6,6,12,.88)';ctx.beginPath();ctx.roundRect(sx,ay+8,180,76,8);ctx.fill();
ctx2.top.forEach((t,i)=>{let y=ay+18+i*22;
ctx.fillStyle='#111120';ctx.beginPath();ctx.roundRect(sx+8,y,140,17,3);ctx.fill();
ctx.fillStyle='#4ecdc4'+(Math.round(t.p*200+55).toString(16).padStart(2,'0'));
ctx.beginPath();ctx.roundRect(sx+8,y,140*t.p,17,3);ctx.fill();
ctx.fillStyle='#e4e2df';ctx.font='600 9px Fira Code';ctx.fillText('"'+t.w+'" '+(t.p*100|0)+'%',sx+12,y+12)});
// Arrows
ctx.fillStyle='#4a475a';ctx.font='14px sans-serif';ctx.fillText('‚Üí',152,ay+50);ctx.fillText('‚Üí',292,ay+50);
// Embedding space
let ex=530,ey=ay;
ctx.fillStyle='#ffd166';ctx.font='600 10px Fira Code';ctx.fillText('Word Embedding Space:',ex,ey);
ctx.fillStyle='rgba(6,6,12,.85)';ctx.beginPath();ctx.roundRect(ex,ey+8,205,158,8);ctx.fill();
vocab.slice(0,12).forEach((w,i)=>{let emb=embeddings[w];let px=ex+12+(emb[0]-120)*0.8,py=ey+20+(emb[1]-60)*1.1;
let isCtx=ctx2.words.includes(w);let isPred=ctx2.top.some(t=>t.w===w);
ctx.beginPath();ctx.arc(px,py,isCtx?7:isPred?5:3,0,TAU);
ctx.fillStyle=isCtx?'#38bdf8':isPred?'#4ecdc4':'#4a475a';ctx.fill();
if(isCtx||isPred){ctx.fillStyle=isCtx?'#38bdf8':'#4ecdc4';ctx.font='500 7px Fira Code';ctx.textAlign='center';ctx.fillText(w,px,py-10);ctx.textAlign='left'}});
// Bottom
ctx.fillStyle='rgba(6,6,12,.85)';ctx.beginPath();ctx.roundRect(15,270,720,42,8);ctx.fill();
ctx.fillStyle='#ffd166';ctx.font='600 9px Fira Code';ctx.fillText('NNLM (Bengio 2003) ‚Äî The ancestor of GPT:',25,288);
ctx.fillStyle='#7d7a8c';ctx.font='400 9px Fira Code';
ctx.fillText('Each word ‚Üí dense vector. Feed context embeddings through a neural net ‚Üí predict next word probability.',25,305)}
c.onclick=e=>{let r=c.getBoundingClientRect(),mx=(e.clientX-r.left)*750/r.width,my=(e.clientY-r.top)*320/r.height;
contexts.forEach((cc,i)=>{let x=15+(i%4)*183,y=24+Math.floor(i/4)*32;
if(mx>=x&&mx<=x+176&&my>=y&&my<=y+26){selected=i;draw()}})};
const ctrl=addControls(el);const rst=document.createElement('button');rst.className='btn';rst.textContent='‚Üª Reset';
rst.onclick=()=>{selected=0;draw()};ctrl.appendChild(rst);draw()})();
</script></body></html>
