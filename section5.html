<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Section V — Eve of Deep Learning · How AI Works</title>
<link rel="stylesheet" href="styles.css">
</head><body>
<div class="progress-bar" style="background:linear-gradient(90deg,var(--a4),var(--a5))"></div>
<button class="back-top" onclick="window.scrollTo({top:0,behavior:'smooth'})">↑</button>
<nav class="topnav"><a href="index.html" class="logo">How AI Works</a><div class="nav-links"><a href="section1.html">I</a><a href="section2.html">II</a><a href="section3.html">III</a><a href="section4.html">IV</a><a href="section5.html" class="active">V</a><a href="section6.html">VI</a><a href="section7.html">VII</a><a href="section8.html">VIII</a></div></nav>
<div class="section-hero" style="background:radial-gradient(ellipse 60% 50% at 50% 70%,rgba(167,139,250,.06),transparent)">
  <div class="era-label" style="color:var(--a4)">Section V · 2000s</div>
  <h1>The Eve of Deep Learning</h1>
  <p>Layer-wise pretraining, autoencoders, and gradient boosting -- the crucial preparations before the deep learning revolution.</p>
  <div class="nav-arrows"><a href="section4.html">&larr; Section IV</a><a href="section6.html">Section VI &rarr;</a></div>
</div>
<div class="models-container">

<div class="model-card"><div class="mc-head"><span class="mc-year" style="color:var(--a4)">2006</span><div class="mc-info"><h3>Deep Belief Network (DBN)</h3><p>Hinton's breakthrough -- pretrain deep networks layer by layer with unsupervised RBMs, then fine-tune with backprop. This solved the vanishing gradient problem for deep nets and reignited interest in deep learning.</p></div></div>
<div class="mc-formula" style="color:var(--a4)">Layer 1: RBM pretrain -> Layer 2: RBM pretrain -> ... -> Fine-tune with backprop</div>
<div class="mc-demo" id="demo-dbn"></div></div>

<div class="model-card"><div class="mc-head"><span class="mc-year" style="color:var(--a4)">2006</span><div class="mc-info"><h3>Sparse Autoencoder</h3><p>Compress input through a narrow bottleneck, then reconstruct. The network learns efficient feature representations. A sparsity constraint forces most neurons to stay inactive, discovering the most salient features.</p></div></div>
<div class="mc-formula" style="color:var(--a4)">minimize ||x - decode(encode(x))||^2 + lambda * sparsity_penalty</div>
<div class="mc-demo" id="demo-sae"></div></div>

<div class="model-card"><div class="mc-head"><span class="mc-year" style="color:var(--a4)">2008</span><div class="mc-info"><h3>Denoising Autoencoder</h3><p>Vincent et al. -- deliberately corrupt the input with noise, then train the network to reconstruct the clean original. This forces the model to learn robust, meaningful features rather than simply memorizing.</p></div></div>
<div class="mc-formula" style="color:var(--a4)">x~ = corrupt(x)    minimize ||x - decode(encode(x~))||^2</div>
<div class="mc-demo" id="demo-dae"></div></div>

<div class="model-card"><div class="mc-head"><span class="mc-year" style="color:var(--a4)">2001</span><div class="mc-info"><h3>GBDT (Gradient Boosted Decision Trees)</h3><p>Friedman's gradient boosting -- each new tree fits the residual errors left by all previous trees. Iteratively reduces loss by adding trees that correct the ensemble's mistakes. Dominates tabular data competitions.</p></div></div>
<div class="mc-formula" style="color:var(--a4)">F_m(x) = F_{m-1}(x) + eta * h_m(x)    where h_m fits residuals of F_{m-1}</div>
<div class="mc-demo" id="demo-gbdt"></div></div>

<div class="model-card"><div class="mc-head"><span class="mc-year" style="color:var(--a4)">2003</span><div class="mc-info"><h3>NNLM (Neural Network Language Model)</h3><p>Bengio et al. -- the first neural language model. Map each word to a dense vector, concatenate a context window, pass through a hidden layer to predict the next word. The ancestor of Word2Vec and all modern LLMs.</p></div></div>
<div class="mc-formula" style="color:var(--a4)">P(w_t | w_{t-n}...w_{t-1}) = softmax( W * tanh(C * [e_{t-n};...;e_{t-1}]) )</div>
<div class="mc-demo" id="demo-nnlm"></div></div>

</div>
<footer><a href="section4.html">&larr; Section IV</a> &middot; <a href="section6.html">Section VI: Deep Learning Explosion &rarr;</a></footer>
<script src="shared.js"></script>
<script>
// ============ DBN: Layer-by-layer pretraining animation ============
(function(){
const el=$('demo-dbn'),[c,ctx]=createCanvas(el,750,320);
addHint(el,'Click "Pretrain Layer" to greedily train each layer -- then "Fine-tune" to polish with backprop');
const arch=[6,8,6,4,2];let phase='idle',curLayer=0,progress=0,finetuneProgress=0;
let weights=[];for(let l=0;l<arch.length-1;l++){let w=[];for(let j=0;j<arch[l+1];j++){let ww=[];for(let i=0;i<arch[l];i++)ww.push(rand(-.1,.1));w.push(ww)}weights.push(w)}
let layerTrained=[false,false,false,false];
function draw(){ctx.clearRect(0,0,750,320);
const lx=[80,210,340,470,600];
const np=arch.map((n,li)=>Array(n).fill(0).map((_,ni)=>({x:lx[li],y:160-((n-1)*30)/2+ni*30})));
// Edges
for(let l=0;l<arch.length-1;l++)for(let j=0;j<arch[l+1];j++)for(let i=0;i<arch[l];i++){
let a=np[l][i],b=np[l+1][j],w=weights[l][j][i];
let trained=layerTrained[l],active=phase==='pretrain'&&l===curLayer;
let alpha=trained?.3+Math.abs(w)*.5:.06;if(active)alpha=.2+Math.abs(w)*.8;
ctx.strokeStyle=w>0?`rgba(78,205,196,${alpha})`:`rgba(255,107,107,${alpha})`;
ctx.lineWidth=trained||active?.5+Math.abs(w)*3:.3;ctx.beginPath();ctx.moveTo(a.x+12,a.y);ctx.lineTo(b.x-12,b.y);ctx.stroke()}
// Nodes
arch.forEach((n,li)=>{for(let ni=0;ni<n;ni++){let p=np[li][ni];
let trained=li>0&&layerTrained[li-1]||li===0;
let active=phase==='pretrain'&&(li===curLayer||li===curLayer+1);
ctx.save();if(active){ctx.shadowColor='#a78bfa';ctx.shadowBlur=12}
ctx.beginPath();ctx.arc(p.x,p.y,11,0,TAU);
ctx.fillStyle=active?'rgba(167,139,250,.3)':trained?'rgba(78,205,196,.12)':'#0c0c16';ctx.fill();
ctx.strokeStyle=active?'#a78bfa':trained?'#4ecdc444':'#1e1e32';ctx.lineWidth=active?2:1;ctx.stroke();ctx.restore()}});
// Layer labels & pretrain progress
['Input','RBM 1','RBM 2','RBM 3','Output'].forEach((l,i)=>{
ctx.fillStyle=layerTrained[i]||i===0?'#4ecdc4':phase==='pretrain'&&i===curLayer+1?'#a78bfa':'#4a475a';
ctx.font='400 8px Fira Code';ctx.textAlign='center';ctx.fillText(l,lx[i],300)});
// Training bracket
if(phase==='pretrain'){let l=curLayer;
ctx.strokeStyle='#a78bfa88';ctx.lineWidth=1.5;ctx.setLineDash([3,3]);
ctx.beginPath();ctx.roundRect(lx[l]-25,20,lx[l+1]-lx[l]+50,270,10);ctx.stroke();ctx.setLineDash([]);
ctx.fillStyle='#a78bfa';ctx.font='600 9px Fira Code';ctx.fillText(`Pretraining RBM ${l+1}...`,lx[l]+(lx[l+1]-lx[l])/2,16);
// Progress bar
let bx=lx[l]-20,bw=lx[l+1]-lx[l]+40;
ctx.fillStyle='#111120';ctx.fillRect(bx,285,bw,5);ctx.fillStyle='#a78bfa';ctx.fillRect(bx,285,bw*progress,5)}
if(phase==='finetune'){ctx.fillStyle='#ffd166';ctx.font='600 10px Fira Code';ctx.textAlign='center';ctx.fillText('Fine-tuning with backprop...',375,16);
ctx.fillStyle='#111120';ctx.fillRect(80,285,520,5);ctx.fillStyle='#ffd166';ctx.fillRect(80,285,520*finetuneProgress,5)}
// Status
ctx.textAlign='left';ctx.fillStyle='#7d7a8c';ctx.font='400 9px Fira Code';
ctx.fillText(`Layers trained: ${layerTrained.filter(Boolean).length}/${arch.length-1}`,620,16);
if(phase==='done'){ctx.fillStyle='#34d399';ctx.font='600 12px Fira Code';ctx.textAlign='center';ctx.fillText('\u2705 Training Complete!',375,16);ctx.textAlign='left'}}
function pretrain(){if(curLayer>=arch.length-1){phase='idle';draw();return}
phase='pretrain';progress=0;
let iv=setInterval(()=>{progress+=.03;
for(let j=0;j<arch[curLayer+1];j++)for(let i=0;i<arch[curLayer];i++)weights[curLayer][j][i]+=rand(-.03,.03);
draw();if(progress>=1){clearInterval(iv);layerTrained[curLayer]=true;curLayer++;phase='idle';draw()}},25)}
function finetune(){if(!layerTrained.some(Boolean))return;phase='finetune';finetuneProgress=0;
let iv=setInterval(()=>{finetuneProgress+=.02;
for(let l=0;l<weights.length;l++)for(let j=0;j<weights[l].length;j++)for(let i=0;i<weights[l][j].length;i++)weights[l][j][i]*=1+rand(-.01,.01);
draw();if(finetuneProgress>=1){clearInterval(iv);phase='done';draw()}},25)}
const ctrl=addControls(el);const btn=document.createElement('button');btn.className='btn';btn.textContent='\u25b6 Pretrain Next Layer';btn.onclick=pretrain;
const fb=document.createElement('button');fb.className='btn';fb.textContent='\ud83c\udfaf Fine-tune';fb.onclick=finetune;
const rst=document.createElement('button');rst.className='btn';rst.textContent='\u21ba Reset';rst.onclick=()=>{curLayer=0;phase='idle';finetuneProgress=0;layerTrained=[false,false,false,false];
for(let l=0;l<weights.length;l++)for(let j=0;j<weights[l].length;j++)for(let i=0;i<weights[l][j].length;i++)weights[l][j][i]=rand(-.1,.1);draw()};
ctrl.appendChild(btn);ctrl.appendChild(fb);ctrl.appendChild(rst);draw()})();

// ============ Sparse Autoencoder: Interactive bottleneck ============
(function(){
const el=$('demo-sae'),[c,ctx]=createCanvas(el,750,300);
addHint(el,'Click "Encode" to compress a random input -- adjust bottleneck size to see quality vs compression tradeoff');
let inputDim=12,bottleneck=4,inputVals=[],encoded=[],decoded=[],sparsity=.8;
function randomInput(){inputVals=Array(inputDim).fill(0).map(()=>rand(0,1));encode()}
function encode(){encoded=Array(bottleneck).fill(0).map((_,i)=>{let s=0;inputVals.forEach((v,j)=>s+=v*Math.sin((i+1)*(j+1)*.5));
return Math.tanh(s)*(Math.random()>sparsity?1:.05)});
decoded=Array(inputDim).fill(0).map((_,j)=>{let s=0;encoded.forEach((v,i)=>s+=v*Math.cos((i+1)*(j+1)*.5));return sigmoid(s)})}
randomInput();
function draw(){ctx.clearRect(0,0,750,300);
let ox=30,bw=38,gap=6;
// Input
ctx.fillStyle='#ffd166';ctx.font='600 10px Fira Code';ctx.fillText('Input',ox,20);
inputVals.forEach((v,i)=>{let y=35+i*21;ctx.fillStyle='#111120';ctx.fillRect(ox,y,bw,16);ctx.fillStyle=`rgba(255,209,102,${.2+v*.8})`;ctx.fillRect(ox,y,bw*v,16);
ctx.fillStyle='#7d7a8c';ctx.font='400 7px Fira Code';ctx.fillText(v.toFixed(2),ox+bw+4,y+11)});
// Encoder arrows
let ex=140;ctx.fillStyle='#4a475a';ctx.font='20px sans-serif';ctx.fillText('\u2192',ex,160);
// Bottleneck
let bx=190;ctx.fillStyle='#a78bfa';ctx.font='600 10px Fira Code';ctx.fillText(`Bottleneck (${bottleneck}D)`,bx,20);
let bStartY=35+(inputDim-bottleneck)*21/2;
encoded.forEach((v,i)=>{let y=bStartY+i*21;let active=Math.abs(v)>.1;
ctx.fillStyle='#111120';ctx.fillRect(bx,y,60,16);ctx.fillStyle=active?`rgba(167,139,250,${.2+Math.abs(v)*.8})`:'rgba(167,139,250,.05)';
ctx.fillRect(bx,y,60*Math.abs(v),16);
ctx.fillStyle=active?'#e4e2df':'#4a475a';ctx.font='400 7px Fira Code';ctx.fillText(v.toFixed(2),bx+64,y+11);
if(!active){ctx.fillStyle='#ff6b6b44';ctx.font='400 7px Fira Code';ctx.fillText('sparse',bx+64,y+11)}});
// Decoder arrows
ctx.fillStyle='#4a475a';ctx.font='20px sans-serif';ctx.fillText('\u2192',310,160);
// Decoded output
let dx=360;ctx.fillStyle='#4ecdc4';ctx.font='600 10px Fira Code';ctx.fillText('Reconstruction',dx,20);
decoded.forEach((v,i)=>{let y=35+i*21;ctx.fillStyle='#111120';ctx.fillRect(dx,y,bw,16);ctx.fillStyle=`rgba(78,205,196,${.2+v*.8})`;ctx.fillRect(dx,y,bw*v,16);
ctx.fillStyle='#7d7a8c';ctx.font='400 7px Fira Code';ctx.fillText(v.toFixed(2),dx+bw+4,y+11)});
// Error comparison
let errx=500;ctx.fillStyle='#ff6b6b';ctx.font='600 10px Fira Code';ctx.fillText('Error',errx,20);
let totalErr=0;inputVals.forEach((v,i)=>{let y=35+i*21,err=Math.abs(v-decoded[i]);totalErr+=err*err;
ctx.fillStyle='#111120';ctx.fillRect(errx,y,bw,16);ctx.fillStyle=`rgba(255,107,107,${err})`;ctx.fillRect(errx,y,bw*err,16)});
ctx.fillStyle='rgba(6,6,12,.88)';ctx.beginPath();ctx.roundRect(590,30,150,120,10);ctx.fill();ctx.strokeStyle='#1e1e32';ctx.lineWidth=1;ctx.beginPath();ctx.roundRect(590,30,150,120,10);ctx.stroke();
ctx.fillStyle='#ffd166';ctx.font='600 11px Fira Code';ctx.fillText('Summary',600,50);
ctx.fillStyle='#7d7a8c';ctx.font='400 9px Fira Code';
ctx.fillText(`Compression: ${inputDim} \u2192 ${bottleneck}`,600,70);
ctx.fillText(`Ratio: ${(bottleneck/inputDim*100).toFixed(0)}%`,600,86);
ctx.fillText(`MSE: ${(totalErr/inputDim).toFixed(4)}`,600,102);
let active=encoded.filter(v=>Math.abs(v)>.1).length;ctx.fillText(`Active neurons: ${active}/${bottleneck}`,600,118);
ctx.fillText(`Sparsity: ${((1-active/bottleneck)*100).toFixed(0)}%`,600,134)}
const ctrl=addControls(el);ctrl.innerHTML='<label>Bottleneck</label><input type="range" min="1" max="10" value="4" id="bn"><span id="bnv" style="font-family:var(--mono);font-size:.7rem;color:var(--a4)">4</span><label>Sparsity</label><input type="range" min="0" max="95" value="80" id="sp"><span id="spv" style="font-family:var(--mono);font-size:.7rem;color:var(--a1)">80%</span>';
$('bn').oninput=e=>{bottleneck=+e.target.value;$('bnv').textContent=bottleneck;encode();draw()};
$('sp').oninput=e=>{sparsity=e.target.value/100;$('spv').textContent=(sparsity*100|0)+'%';encode();draw()};
const btn=document.createElement('button');btn.className='btn';btn.textContent='\ud83c\udfb2 New Input';btn.onclick=()=>{randomInput();draw()};ctrl.appendChild(btn);draw()})();

// ============ Denoising Autoencoder: Noise slider ============
(function(){
const el=$('demo-dae'),[c,ctx]=createCanvas(el,750,250);
addHint(el,'Adjust noise level -- see how the autoencoder learns to denoise corrupted inputs');
let G=10,original=[],noisy=[],recon=[],noise=.3;
function gen(){original=Array(G).fill(0).map(()=>rand(.1,.9));corrupt();reconstruct()}
function corrupt(){noisy=original.map(v=>clamp(v+rand(-noise,noise),0,1))}
function reconstruct(){recon=noisy.map((v,i)=>{let s=v*.3+original[i]*.5+Math.sin(i)*.05;return clamp(sigmoid(s*2-.5),.05,.95)})}
gen();
function draw(){ctx.clearRect(0,0,750,250);let bw=50,bh=160,gap=8;
[{label:'Original',data:original,color:'#ffd166',x:20},{label:`Noisy (${(noise*100|0)}%)`,data:noisy,color:'#ff6b6b',x:260},{label:'Reconstructed',data:recon,color:'#4ecdc4',x:500}].forEach(group=>{
ctx.fillStyle=group.color;ctx.font='600 10px Fira Code';ctx.fillText(group.label,group.x,22);
group.data.forEach((v,i)=>{let x=group.x+i*(bw/G*2+2),y=35;
ctx.fillStyle='#111120';ctx.fillRect(x,y,bw/G*2,bh);
ctx.fillStyle=group.color+'88';ctx.fillRect(x,y+bh*(1-v),bw/G*2,bh*v)})});
// Arrows
ctx.fillStyle='#4a475a';ctx.font='20px sans-serif';ctx.fillText('\u2192 corrupt \u2192',180,120);ctx.fillText('\u2192 denoise \u2192',420,120);
// Error
let err=original.reduce((a,v,i)=>a+(v-recon[i])**2,0)/G;
ctx.fillStyle='#7d7a8c';ctx.font='400 10px Fira Code';ctx.fillText(`Reconstruction MSE: ${err.toFixed(4)}`,20,230);
ctx.fillStyle=err<.01?'#34d399':'#ffd166';ctx.fillText(err<.01?'Excellent recovery!':err<.05?'Good recovery':'Significant loss',250,230)}
const ctrl=addControls(el);ctrl.innerHTML='<label>Noise Level</label><input type="range" min="0" max="80" value="30" id="nl"><span id="nlv" style="font-family:var(--mono);font-size:.7rem;color:var(--a1)">30%</span>';
$('nl').oninput=e=>{noise=e.target.value/100;$('nlv').textContent=(noise*100|0)+'%';corrupt();reconstruct();draw()};
const btn=document.createElement('button');btn.className='btn';btn.textContent='\ud83c\udfb2 New Signal';btn.onclick=()=>{gen();draw()};ctrl.appendChild(btn);draw()})();

// ============ GBDT: Residual fitting animation ============
(function(){
const el=$('demo-gbdt'),[c,ctx]=createCanvas(el,750,320);
addHint(el,'Click "Add Tree" -- each new tree fits the residual errors left by the ensemble');
let xs=Array(20).fill(0).map((_,i)=>i*35+25);let ys=xs.map(x=>Math.sin(x*.02)*120+160+rand(-15,15));
let trees=[],lr=.3;
function treePred(x,tree){return tree.reduce((a,seg)=>a+(x>=seg.lo&&x<seg.hi?seg.val:0),0)}
function ensemble(x){return trees.reduce((a,t)=>a+lr*treePred(x,t),0)}
function addTree(){let residuals=xs.map((x,i)=>ys[i]-ensemble(x));
let segs=[];for(let s=0;s<700;s+=140){let vals=[];xs.forEach((x,i)=>{if(x>=s&&x<s+140)vals.push(residuals[i])});
segs.push({lo:s,hi:s+140,val:vals.length?vals.reduce((a,b)=>a+b,0)/vals.length:0})}
trees.push(segs);draw()}
function draw(){ctx.clearRect(0,0,750,320);
ctx.strokeStyle='#151520';ctx.lineWidth=1;for(let y=0;y<=320;y+=40){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(750,y);ctx.stroke()}
// True values
xs.forEach((x,i)=>{ctx.beginPath();ctx.arc(x,ys[i],4,0,TAU);ctx.fillStyle='#ffd166';ctx.fill()});
// Current prediction line
if(trees.length>0){ctx.strokeStyle='#4ecdc4';ctx.lineWidth=2.5;ctx.beginPath();
for(let x=0;x<750;x+=3){let y=ensemble(x);x===0?ctx.moveTo(x,160-y+160):ctx.lineTo(x,160-y+160)}ctx.stroke();
// Residuals
xs.forEach((x,i)=>{let py=160-ensemble(x)+160;ctx.strokeStyle='rgba(255,107,107,.3)';ctx.lineWidth=1;ctx.beginPath();ctx.moveTo(x,ys[i]);ctx.lineTo(x,py);ctx.stroke()})}
// Latest tree (step function)
if(trees.length>0){let last=trees[trees.length-1];ctx.strokeStyle='#a78bfa55';ctx.lineWidth=1.5;ctx.setLineDash([4,4]);
last.forEach(seg=>{ctx.beginPath();ctx.moveTo(seg.lo,160-seg.val*lr+160);ctx.lineTo(seg.hi,160-seg.val*lr+160);ctx.stroke()});ctx.setLineDash([])}
let mse=trees.length?xs.reduce((a,x,i)=>a+(ys[i]-(160-ensemble(x)+160))**2,0)/xs.length:0;
ctx.fillStyle='rgba(6,6,12,.85)';ctx.beginPath();ctx.roundRect(580,10,160,70,8);ctx.fill();
ctx.fillStyle='#ffd166';ctx.font='600 10px Fira Code';ctx.fillText(`Trees: ${trees.length}`,592,30);
ctx.fillStyle='#ff6b6b';ctx.fillText(`MSE: ${mse.toFixed(1)}`,592,48);
ctx.fillStyle='#7d7a8c';ctx.fillText(`LR: ${lr}`,592,66)}
const ctrl=addControls(el);const btn=document.createElement('button');btn.className='btn';btn.textContent='\ud83c\udf32 Add Tree';btn.onclick=addTree;
let timer=null;const abtn=document.createElement('button');abtn.className='btn';abtn.textContent='\u23e9 Auto';
abtn.onclick=()=>{if(timer){clearInterval(timer);timer=null;abtn.classList.remove('active')}else{timer=setInterval(()=>{addTree();if(trees.length>=15){clearInterval(timer);timer=null;abtn.classList.remove('active')}},250);abtn.classList.add('active')}};
const rst=document.createElement('button');rst.className='btn';rst.textContent='\u21ba';rst.onclick=()=>{trees=[];draw()};
ctrl.appendChild(btn);ctrl.appendChild(abtn);ctrl.appendChild(rst);draw()})();

// ============ NNLM: Next word prediction ============
(function(){
const el=$('demo-nnlm'),[c,ctx]=createCanvas(el,750,280);
addHint(el,'Click a context window position to change words -- see how the model predicts the next word');
const vocab=['the','cat','sat','on','mat','dog','ran','to','big','small','red','blue','house','tree','and','a'];
let context=['the','big','cat','sat'];let prediction=[];
function predict(){let hash=0;context.forEach((w,i)=>{for(let j=0;j<w.length;j++)hash+=w.charCodeAt(j)*(i+1)});
prediction=vocab.map(w=>{let s=0;for(let i=0;i<w.length;i++)s+=Math.sin(hash*.01+w.charCodeAt(i)*.1)*Math.cos(i+hash*.005);return{w,p:Math.exp(s)}});
let total=prediction.reduce((a,p)=>a+p.p,0);prediction.forEach(p=>p.p/=total);prediction.sort((a,b)=>b.p-a.p)}
predict();let selectedSlot=-1;
function draw(){ctx.clearRect(0,0,750,280);
// Context window
ctx.fillStyle='#ffd166';ctx.font='600 11px Fira Code';ctx.fillText('Context Window (n-gram):',20,25);
let wx=20;context.forEach((w,i)=>{let bw=Math.max(w.length*11+16,50),bh=36;
ctx.save();if(i===selectedSlot){ctx.shadowColor='#ffd166';ctx.shadowBlur=10}
ctx.beginPath();ctx.roundRect(wx,35,bw,bh,8);ctx.fillStyle=i===selectedSlot?'rgba(255,209,102,.15)':'rgba(255,209,102,.06)';ctx.fill();
ctx.strokeStyle=i===selectedSlot?'#ffd166':'#ffd16644';ctx.lineWidth=1.5;ctx.stroke();ctx.restore();
ctx.fillStyle='#fff';ctx.font='600 14px Fira Code';ctx.textAlign='center';ctx.fillText(w,wx+bw/2,58);
ctx.fillStyle='#4a475a';ctx.font='400 7px Fira Code';ctx.fillText(`w_{t-${context.length-i}}`,wx+bw/2,72);
ctx.textAlign='left';wx+=bw+10});
// Arrow
ctx.fillStyle='#4a475a';ctx.font='24px sans-serif';ctx.fillText('\u2192',wx+5,58);
// Embedding visualization
ctx.fillStyle='#a78bfa88';ctx.font='400 9px Fira Code';ctx.fillText('embeddings \u2192 hidden layer \u2192 softmax',20,105);
// Prediction bars
ctx.fillStyle='#4ecdc4';ctx.font='600 10px Fira Code';ctx.fillText('P(next word):',20,128);
prediction.slice(0,8).forEach((p,i)=>{let y=138+i*17,barW=350;
ctx.fillStyle='#111120';ctx.fillRect(80,y,barW,13);
ctx.fillStyle=i===0?'#4ecdc4aa':'rgba(78,205,196,.25)';ctx.fillRect(80,y,barW*p.p,13);
ctx.fillStyle=i===0?'#fff':'#7d7a8c';ctx.font=`${i===0?'600 ':'400 '}9px Fira Code`;ctx.fillText(p.w,20,y+10);
ctx.fillStyle='#e4e2df';ctx.textAlign='right';ctx.fillText((p.p*100).toFixed(1)+'%',80+barW+35,y+10);ctx.textAlign='left'});
// Right panel
ctx.fillStyle='rgba(6,6,12,.88)';ctx.beginPath();ctx.roundRect(520,115,215,150,10);ctx.fill();ctx.strokeStyle='#1e1e32';ctx.lineWidth=1;ctx.beginPath();ctx.roundRect(520,115,215,150,10);ctx.stroke();
ctx.fillStyle='#ffd166';ctx.font='600 10px Fira Code';ctx.fillText('How NNLM works:',530,135);
ctx.fillStyle='#7d7a8c';ctx.font='400 9px DM Sans';
['1. Each word \u2192 dense embedding vector','2. Concatenate context embeddings','3. Feed through hidden layer + tanh','4. Softmax over vocabulary','','First neural approach to language!','Ancestor of Word2Vec and GPT.'].forEach((l,i)=>ctx.fillText(l,530,153+i*15))}
c.onclick=e=>{let r=c.getBoundingClientRect(),mx=(e.clientX-r.left)*750/r.width,my=(e.clientY-r.top)*280/r.height;
if(my>35&&my<71){let wx=20;for(let i=0;i<context.length;i++){let bw=Math.max(context[i].length*11+16,50);if(mx>=wx&&mx<=wx+bw){selectedSlot=i;
context[i]=vocab[randInt(0,vocab.length)];predict();draw();return}wx+=bw+10}}};
const ctrl=addControls(el);const btn=document.createElement('button');btn.className='btn';btn.textContent='\ud83c\udfb2 Random Context';
btn.onclick=()=>{context=Array(4).fill(0).map(()=>vocab[randInt(0,vocab.length)]);predict();draw()};ctrl.appendChild(btn);draw()})();
</script></body></html>
