<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Section III ‚Äî The Revival & Classical ML ¬∑ How AI Works</title>
<link rel="stylesheet" href="styles.css">
</head><body>
<div class="progress-bar" style="background:linear-gradient(90deg,var(--a3),var(--a2))"></div>
<button class="back-top" onclick="window.scrollTo({top:0,behavior:'smooth'})">‚Üë</button>
<nav class="topnav"><a href="index.html" class="logo">How AI Works</a><div class="nav-links"><a href="section1.html">I</a><a href="section2.html">II</a><a href="section3.html" class="active">III</a><a href="section4.html">IV</a><a href="section5.html">V</a><a href="section6.html">VI</a><a href="section7.html">VII</a><a href="section8.html">VIII</a></div></nav>
<div class="section-hero"><div class="era-label" style="color:var(--a3)">Section III ¬∑ 1980s</div>
<h1>The Revival & Classical ML</h1><p>Backpropagation revives neural networks. Decision trees, RNNs, and Boltzmann machines emerge.</p>
<div class="nav-arrows"><a href="section2.html">&larr; Section II</a><a href="section4.html">Section IV &rarr;</a></div></div>
<div class="models-container">

<!-- ======= NEOCOGNITRON ======= -->
<div class="model-card" id="model-neocognitron"><div class="mc-head"><span class="mc-year" style="color:var(--a3)">1980</span><div class="mc-info">
<h3>Neocognitron <a href="https://doi.org/10.1007/BF00344251" target="_blank" class="paper-link">Paper</a></h3>
<p>Fukushima's hierarchical pattern recognizer ‚Äî inspired by the visual cortex. Simple cells detect local features, complex cells pool them for translation invariance.</p>
<div class="model-lineage">Extends <a href="section1.html#model-perceptron">Perceptron</a> into a hierarchical architecture; the direct ancestor of <a href="section4.html#model-cnn">CNN/LeNet</a> (adds backprop-based training).</div>
</div></div>
<div class="mc-formula" style="color:var(--a3)">S-cells (feature detect) ‚Üí C-cells (pool/invariance) ‚Üí deeper layers ‚Üí recognition</div>
<div class="mc-demo" id="demo-neo"></div></div>

<!-- ======= RNN ======= -->
<div class="model-card" id="model-rnn"><div class="mc-head"><span class="mc-year" style="color:var(--a3)">1986</span><div class="mc-info">
<h3>RNN (Recurrent Neural Network) <a href="https://doi.org/10.1038/323533a0" target="_blank" class="paper-link">Paper</a></h3>
<p>Networks with loops ‚Äî the hidden state acts as memory, carrying information from previous time steps. Essential for sequences like text, speech, and time series.</p>
<div class="model-lineage">Overcomes <a href="section1.html#model-markov">Markov Chain</a>'s memoryless limitation by adding recurrence; its vanishing gradient problem is solved by <a href="section4.html#model-lstm">LSTM</a>.</div>
</div></div>
<div class="mc-formula" style="color:var(--a3)">h‚Çú = tanh(W_h ¬∑ h‚Çú‚Çã‚ÇÅ + W_x ¬∑ x‚Çú + b) ‚Äî hidden state = f(previous state + current input)</div>
<div class="mc-demo" id="demo-rnn"></div></div>

<!-- ======= BOLTZMANN MACHINE ======= -->
<div class="model-card" id="model-boltzmann"><div class="mc-head"><span class="mc-year" style="color:var(--a3)">1985</span><div class="mc-info">
<h3>Boltzmann Machine <a href="https://doi.org/10.1016/S0364-0213(85)80012-4" target="_blank" class="paper-link">Paper</a></h3>
<p>Hinton & Sejnowski's stochastic network ‚Äî neurons randomly flip on/off based on their energy. Lower energy states are more likely.</p>
<div class="model-lineage">Introduces energy-based probabilistic learning inspired by <a href="section1.html#model-markov">Markov Chain</a> sampling; its restricted variant directly leads to <a href="section5.html#model-dbn">DBN</a> pretraining.</div>
</div></div>
<div class="mc-formula" style="color:var(--a3)">P(state) ‚àù e^(-Energy/T) ‚Äî lower energy = more probable. Energy = -Œ£ w·µ¢‚±º s·µ¢ s‚±º</div>
<div class="mc-demo" id="demo-boltz"></div></div>

<!-- ======= BACKPROPAGATION ======= -->
<div class="model-card" id="model-backprop"><div class="mc-head"><span class="mc-year" style="color:var(--a3)">1986</span><div class="mc-info">
<h3>Backpropagation <a href="https://doi.org/10.1038/323533a0" target="_blank" class="paper-link">Paper</a></h3>
<p>Rumelhart, Hinton & Williams made neural networks trainable. Compute the error at the output, then propagate gradients backward through each layer.</p>
<div class="model-lineage">Applies the <a href="section2.html#model-chainrule">Chain Rule</a> to multi-layer networks, solving <a href="section1.html#model-perceptron">Perceptron</a>'s XOR problem; enables ALL deep learning from <a href="section4.html#model-cnn">CNN</a> to <a href="section7.html#model-transformer">Transformer</a>.</div>
</div></div>
<div class="mc-formula" style="color:var(--a3)">‚àÇLoss/‚àÇw·µ¢ = ‚àÇLoss/‚àÇoutput ¬∑ ‚àÇoutput/‚àÇhidden ¬∑ ‚àÇhidden/‚àÇw·µ¢ ‚Äî chain rule through layers</div>
<div class="mc-demo" id="demo-bp"></div></div>

<!-- ======= DECISION TREE ======= -->
<div class="model-card" id="model-dtree"><div class="mc-head"><span class="mc-year" style="color:var(--a3)">1986</span><div class="mc-info">
<h3>Decision Tree <a href="https://link.springer.com/article/10.1007/BF00116251" target="_blank" class="paper-link">Paper</a></h3>
<p>Quinlan's ID3 algorithm ‚Äî recursively split data on the feature that gives the most information gain. Simple, fast, and explainable.</p>
<div class="model-lineage">A non-neural alternative to <a href="section1.html#model-perceptron">Perceptron</a>; later ensembled into <a href="section4.html#model-randomforest">Random Forest</a>, <a href="section5.html#model-gbdt">GBDT</a>, and <a href="section7.html#model-xgboost">XGBoost</a>.</div>
</div></div>
<div class="mc-formula" style="color:var(--a3)">Split on feature with max Information Gain = H(parent) - Œ£ (|child|/|parent|) H(child)</div>
<div class="mc-demo" id="demo-tree"></div></div>

</div>
<footer><a href="section2.html">&larr; Section II</a> &middot; <a href="section4.html">Section IV: Golden Age &rarr;</a></footer>
<script src="shared.js"></script>
<script>
// ===== NEOCOGNITRON ‚Äî Hierarchical feature extraction =====
(function(){const el=$('demo-neo'),[c,ctx]=createCanvas(el,750,340);
addHint(el,'Draw on the 8√ó8 grid (left). Watch features get detected layer by layer, just like the visual cortex!');
let grid=Array(8).fill(0).map(()=>Array(8).fill(0)),drawing=false;
const filters=[
{name:'Horiz',k:[[1,1],[-.5,-.5]],c:'#ff6b6b'},
{name:'Vert',k:[[1,-.5],[1,-.5]],c:'#38bdf8'},
{name:'Diag\\',k:[[1,-.5],[-.5,1]],c:'#ffd166'},
{name:'Diag/',k:[[-.5,1],[1,-.5]],c:'#a78bfa'}];
function conv2d(g,k){let h=g.length-k.length+1,w=g[0].length-k[0].length+1;let out=[];
for(let r=0;r<h;r++){out[r]=[];for(let cc=0;cc<w;cc++){let s=0;
for(let kr=0;kr<k.length;kr++)for(let kc=0;kc<k[0].length;kc++)s+=g[r+kr][cc+kc]*k[kr][kc];
out[r][cc]=Math.max(0,s)}}return out}
function pool2x2(g){let out=[];for(let r=0;r<g.length-1;r+=2){out[r/2]=[];
for(let cc=0;cc<g[0].length-1;cc+=2)out[r/2][cc/2]=Math.max(g[r][cc],g[r][cc+1],g[r+1][cc],g[r+1][cc+1])}return out}
function draw(){ctx.clearRect(0,0,750,340);
let cs=28,ox=15,oy=30;
// Input grid
ctx.fillStyle='#ffd166';ctx.font='600 11px Fira Code';ctx.fillText('Input (8√ó8)',ox,oy-8);
for(let r=0;r<8;r++)for(let cc=0;cc<8;cc++){ctx.fillStyle=grid[r][cc]?'#e4e2df':'#151520';
ctx.fillRect(ox+cc*cs,oy+r*cs,cs-2,cs-2);ctx.strokeStyle='#1e1e32';ctx.strokeRect(ox+cc*cs,oy+r*cs,cs-2,cs-2)}
// S-cells
let sx=270,fmaps=filters.map(f=>conv2d(grid,f.k));
ctx.fillStyle='#4ecdc4';ctx.font='600 11px Fira Code';ctx.fillText('S-Cells (features)',sx,oy-8);
fmaps.forEach((fm,fi)=>{let fy=oy+fi*62;let fcs=8;
ctx.fillStyle=filters[fi].c;ctx.font='500 8px Fira Code';ctx.fillText(filters[fi].name,sx,fy+10);
for(let r=0;r<fm.length;r++)for(let cc=0;cc<fm[0].length;cc++){let v=fm[r][cc];
let cols=[[255,107,107],[56,189,248],[255,209,102],[167,139,250]];
ctx.fillStyle=`rgba(${cols[fi].join(',')},${Math.min(v/2,.9)})`;
ctx.fillRect(sx+45+cc*fcs,fy,fcs-1,fcs-1)}});
// C-cells
let cx2=440;
ctx.fillStyle='#fb923c';ctx.font='600 11px Fira Code';ctx.fillText('C-Cells (pooled)',cx2,oy-8);
let pooled=fmaps.map(fm=>pool2x2(fm));
pooled.forEach((pm,fi)=>{let fy=oy+fi*62;let pcs=14;
ctx.fillStyle=filters[fi].c;ctx.font='500 8px Fira Code';ctx.fillText(filters[fi].name,cx2,fy+10);
if(!pm.length)return;
let cols=[[255,107,107],[56,189,248],[255,209,102],[167,139,250]];
for(let r=0;r<pm.length;r++)for(let cc=0;cc<pm[0].length;cc++){let v=pm[r][cc];
ctx.fillStyle=`rgba(${cols[fi].join(',')},${Math.min(v/1.5,.9)})`;
ctx.fillRect(cx2+45+cc*pcs,fy,pcs-1,pcs-1)}});
// Recognition output
let rx=600;ctx.fillStyle='rgba(6,6,12,.88)';ctx.beginPath();ctx.roundRect(rx,oy,140,240,10);ctx.fill();
ctx.fillStyle='#34d399';ctx.font='600 11px Fira Code';ctx.fillText('Recognition',rx+10,oy+20);
let scores=[0,0,0,0];
pooled.forEach((pm,fi)=>{pm.forEach(row=>row.forEach(v=>{scores[fi]+=v}))});
let total=scores.reduce((a,b)=>a+b,0)||1;
let labels=['Horizontal','Vertical','Diagonal \\','Diagonal /'];
scores.forEach((s,i)=>{let pct=s/total*100;let y=oy+38+i*48;
ctx.fillStyle=filters[i].c;ctx.font='600 9px Fira Code';ctx.fillText(labels[i],rx+10,y);
ctx.fillStyle='#111120';ctx.beginPath();ctx.roundRect(rx+10,y+6,115,16,3);ctx.fill();
ctx.fillStyle=filters[i].c+'88';ctx.beginPath();ctx.roundRect(rx+10,y+6,115*pct/100,16,3);ctx.fill();
ctx.fillStyle='#e4e2df';ctx.font='500 9px Fira Code';ctx.fillText(pct.toFixed(0)+'%',rx+14,y+19)});
// Arrows
ctx.fillStyle='#4a475a';ctx.font='20px sans-serif';ctx.fillText('‚Üí',245,oy+120);ctx.fillText('‚Üí',415,oy+120);ctx.fillText('‚Üí',575,oy+120)}
let mouse=trackMouse(c,750,340);
c.onmousedown=e=>{drawing=true;let r=c.getBoundingClientRect();
let mx2=(e.clientX-r.left)*750/r.width,my=(e.clientY-r.top)*340/r.height;
let gx=Math.floor((mx2-15)/28),gy=Math.floor((my-30)/28);
if(gx>=0&&gx<8&&gy>=0&&gy<8){grid[gy][gx]=grid[gy][gx]?0:1;draw()}};
c.onmousemove=e=>{if(!drawing)return;let r=c.getBoundingClientRect();
let mx2=(e.clientX-r.left)*750/r.width,my=(e.clientY-r.top)*340/r.height;
let gx=Math.floor((mx2-15)/28),gy=Math.floor((my-30)/28);
if(gx>=0&&gx<8&&gy>=0&&gy<8){grid[gy][gx]=1;draw()}};
c.onmouseup=()=>drawing=false;c.onmouseleave=()=>drawing=false;
const ctrl=addControls(el);
[{n:'H-line',g:()=>{grid=Array(8).fill(0).map(()=>Array(8).fill(0));for(let c2=0;c2<8;c2++)grid[4][c2]=1}},
{n:'V-line',g:()=>{grid=Array(8).fill(0).map(()=>Array(8).fill(0));for(let r=0;r<8;r++)grid[r][4]=1}},
{n:'Diag',g:()=>{grid=Array(8).fill(0).map(()=>Array(8).fill(0));for(let i=0;i<8;i++)grid[i][i]=1}},
{n:'Box',g:()=>{grid=Array(8).fill(0).map(()=>Array(8).fill(0));for(let i=2;i<6;i++){grid[2][i]=1;grid[5][i]=1;grid[i][2]=1;grid[i][5]=1}}}
].forEach(p=>{let b=document.createElement('button');b.className='btn';b.textContent=p.n;b.onclick=()=>{p.g();draw()};ctrl.appendChild(b)});
const rst=document.createElement('button');rst.className='btn';rst.textContent='‚Üª Clear';rst.onclick=()=>{grid=Array(8).fill(0).map(()=>Array(8).fill(0));draw()};
ctrl.appendChild(rst);draw()})();

// ===== RNN ‚Äî Sequence memory demo =====
(function(){const el=$('demo-rnn'),[c,ctx]=createCanvas(el,750,320);
addHint(el,'Feed words one at a time. Watch the hidden state (memory) evolve ‚Äî it carries context from ALL previous words!');
const sentence=['The','cat','sat','on','the','warm','sunny','mat'];
let pos=-1,hiddenState=Array(6).fill(0),states=[];
function feedWord(){if(pos>=sentence.length-1)return;pos++;
let word=sentence[pos];
let embed=word.split('').reduce((a,c2,i)=>a+c2.charCodeAt(0)*(i+1),0)/500;
hiddenState=hiddenState.map((h,i)=>Math.tanh(h*.6+embed*(.3+i*.1)+Math.sin(pos+i)*.2));
states.push({word,h:[...hiddenState]});draw()}
function draw(){ctx.clearRect(0,0,750,320);
// Word sequence
let wx=30,wy=22,ww=82;
sentence.forEach((w,i)=>{let x=wx+i*ww;let fed=i<=pos;
ctx.fillStyle=fed?(i===pos?'rgba(255,209,102,.15)':'rgba(78,205,196,.06)'):'#0c0c16';
ctx.beginPath();ctx.roundRect(x,wy,ww-6,32,6);ctx.fill();
ctx.strokeStyle=fed?(i===pos?'#ffd166':'#4ecdc444'):'#1e1e32';ctx.lineWidth=i===pos?2:1;
ctx.beginPath();ctx.roundRect(x,wy,ww-6,32,6);ctx.stroke();
ctx.fillStyle=fed?'#e4e2df':'#4a475a';ctx.font=(i===pos?'600 ':'400 ')+'11px Fira Code';ctx.textAlign='center';
ctx.fillText(w,x+ww/2-3,wy+21);ctx.textAlign='left';
if(i<sentence.length-1&&fed){ctx.fillStyle='#4ecdc433';ctx.beginPath();
ctx.moveTo(x+ww-6,wy+16);ctx.lineTo(x+ww+2,wy+12);ctx.lineTo(x+ww+2,wy+20);ctx.fill()}});
// RNN cell
let cy2=76,cellX=300,cellW=150,cellH=65;
ctx.fillStyle='rgba(78,205,196,.06)';ctx.beginPath();ctx.roundRect(cellX,cy2,cellW,cellH,10);ctx.fill();
ctx.strokeStyle='#4ecdc4';ctx.lineWidth=2;ctx.beginPath();ctx.roundRect(cellX,cy2,cellW,cellH,10);ctx.stroke();
ctx.fillStyle='#4ecdc4';ctx.font='600 12px Fira Code';ctx.textAlign='center';ctx.fillText('RNN Cell',cellX+cellW/2,cy2+22);
ctx.fillStyle='#7d7a8c';ctx.font='400 9px Fira Code';ctx.fillText('h = tanh(W_h¬∑h + W_x¬∑x)',cellX+cellW/2,cy2+40);
// Recurrent arrow
ctx.strokeStyle='#ffd166';ctx.lineWidth=1.5;ctx.beginPath();
ctx.moveTo(cellX+cellW,cy2+32);ctx.quadraticCurveTo(cellX+cellW+30,cy2-12,cellX+cellW/2,cy2-8);
ctx.quadraticCurveTo(cellX-10,cy2-12,cellX,cy2+32);ctx.stroke();
ctx.fillStyle='#ffd166';ctx.font='600 8px Fira Code';ctx.fillText('h_{t-1} ‚Üí h_t',cellX+cellW/2,cy2-15);
// Input arrow
ctx.strokeStyle='#38bdf8';ctx.lineWidth=1.5;ctx.beginPath();ctx.moveTo(cellX+cellW/2,cy2+cellH);ctx.lineTo(cellX+cellW/2,cy2+cellH+18);ctx.stroke();
ctx.fillStyle='#38bdf8';ctx.font='500 9px Fira Code';ctx.fillText('x_t = "'+(pos>=0?sentence[pos]:'?')+'"',cellX+cellW/2,cy2+cellH+32);
ctx.textAlign='left';
// Hidden state bars
let hy=180,hh=100;
ctx.fillStyle='#ffd166';ctx.font='600 10px Fira Code';ctx.fillText('Hidden State h (memory) over time:',30,hy);
if(states.length>0){let bw=Math.min(80,680/states.length);
let colors=['#ff6b6b','#38bdf8','#ffd166','#4ecdc4','#a78bfa','#fb923c'];
states.forEach((s,si)=>{let x=35+si*bw;
s.h.forEach((v,di)=>{let barH=(v+1)/2*14;
ctx.fillStyle=colors[di]+'77';ctx.fillRect(x,hy+15+di*14,bw-3,Math.max(barH,2))});
ctx.fillStyle=si===pos?'#ffd166':'#7d7a8c';ctx.font='500 8px Fira Code';ctx.textAlign='center';
ctx.fillText(s.word,x+bw/2,hy+hh+12);ctx.textAlign='left'})}
ctx.fillStyle='rgba(6,6,12,.85)';ctx.beginPath();ctx.roundRect(30,296,690,20,4);ctx.fill();
ctx.fillStyle='#7d7a8c';ctx.font='400 8px Fira Code';
ctx.fillText('6 hidden dims shown as colored bars. The state evolves with EACH word, carrying memory of all previous words!',40,310)}
const ctrl=addControls(el);
const fb2=document.createElement('button');fb2.className='btn';fb2.textContent='‚ñ∂ Feed Next Word';fb2.onclick=feedWord;
let tmr=null;const ab=document.createElement('button');ab.className='btn';ab.textContent='‚è© Auto Feed';
ab.onclick=()=>{if(tmr){clearInterval(tmr);tmr=null;ab.classList.remove('active')}else{tmr=setInterval(()=>{feedWord();if(pos>=sentence.length-1){clearInterval(tmr);tmr=null;ab.classList.remove('active')}},500);ab.classList.add('active')}};
const rst=document.createElement('button');rst.className='btn';rst.textContent='‚Üª Reset';
rst.onclick=()=>{pos=-1;hiddenState=Array(6).fill(0);states=[];if(tmr){clearInterval(tmr);tmr=null;ab.classList.remove('active')}draw()};
ctrl.appendChild(fb2);ctrl.appendChild(ab);ctrl.appendChild(rst);draw()})();

// ===== BOLTZMANN MACHINE ‚Äî Energy-based sampling =====
(function(){const el=$('demo-boltz'),[c,ctx]=createCanvas(el,750,320);
addHint(el,'Click neurons to toggle on/off. Watch the energy change. Press Sample to let the network find low-energy states!');
const N=8;let states2=Array(N).fill(0).map(()=>Math.random()>.5?1:0);
let W=Array(N).fill(0).map(()=>Array(N).fill(0));
for(let i=0;i<N;i++)for(let j=i+1;j<N;j++){W[i][j]=rand(-.8,.8);W[j][i]=W[i][j]}
let temp=2.0,energyHist=[];
function energy(){let E=0;for(let i=0;i<N;i++)for(let j=i+1;j<N;j++)E-=W[i][j]*states2[i]*states2[j];return E}
function gibbsStep(){let i=randInt(0,N);let dE=0;
for(let j=0;j<N;j++)if(j!==i)dE+=W[i][j]*states2[j];
let p=1/(1+Math.exp(-2*dE/temp));states2[i]=Math.random()<p?1:0;
energyHist.push(energy());if(energyHist.length>100)energyHist.shift()}
function draw(){ctx.clearRect(0,0,750,320);let E=energy();
let cx2=180,cy2=148,rad=100;
// Connections
for(let i=0;i<N;i++)for(let j=i+1;j<N;j++){let ai=i/N*TAU-Math.PI/2,aj=j/N*TAU-Math.PI/2;
let x1=cx2+Math.cos(ai)*rad,y1=cy2+Math.sin(ai)*rad,x2=cx2+Math.cos(aj)*rad,y2=cy2+Math.sin(aj)*rad;
let w=W[i][j],active=states2[i]&&states2[j];
ctx.strokeStyle=active?(w>0?'rgba(78,205,196,.6)':'rgba(255,107,107,.6)'):(w>0?'rgba(78,205,196,.08)':'rgba(255,107,107,.08)');
ctx.lineWidth=Math.abs(w)*2.5+(active?1.5:0);ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.stroke()}
// Neurons
for(let i=0;i<N;i++){let a=i/N*TAU-Math.PI/2,x=cx2+Math.cos(a)*rad,y=cy2+Math.sin(a)*rad;
ctx.save();if(states2[i]){ctx.shadowColor='#ffd166';ctx.shadowBlur=16}
ctx.beginPath();ctx.arc(x,y,18,0,TAU);ctx.fillStyle=states2[i]?'#ffd166':'#1e1e32';ctx.fill();
ctx.strokeStyle=states2[i]?'#ffd166':'#4a475a';ctx.lineWidth=2;ctx.stroke();ctx.restore();
ctx.fillStyle=states2[i]?'#000':'#7d7a8c';ctx.font='bold 10px Fira Code';ctx.textAlign='center';
ctx.fillText(states2[i]?'ON':'off',x,y+4);ctx.textAlign='left'}
// Energy panel
ctx.fillStyle='rgba(6,6,12,.9)';ctx.beginPath();ctx.roundRect(310,12,420,85,10);ctx.fill();
ctx.fillStyle='#ff6b6b';ctx.font='900 26px Fraunces';ctx.fillText('E = '+E.toFixed(2),325,48);
ctx.fillStyle='#7d7a8c';ctx.font='500 9px Fira Code';ctx.fillText('Energy = ‚àíŒ£ w·µ¢‚±º s·µ¢ s‚±º',325,66);
ctx.fillText('Lower energy = more probable state',325,82);
ctx.fillStyle='#ffd166';ctx.font='600 9px Fira Code';ctx.fillText('T = '+temp.toFixed(1),600,48);
ctx.fillText(temp>3?'(exploring)':temp<1?'(frozen)':'(cooling)',600,64);
// Energy history
let chy=110,chh=80,chw=400;
ctx.fillStyle='rgba(6,6,12,.85)';ctx.beginPath();ctx.roundRect(310,chy,chw+20,chh+35,10);ctx.fill();
ctx.fillStyle='#ff6b6b';ctx.font='600 9px Fira Code';ctx.fillText('Energy over time:',320,chy+14);
if(energyHist.length>1){let mx2=Math.max(...energyHist),mn=Math.min(...energyHist);if(mx2===mn)mx2=mn+1;
ctx.strokeStyle='#ff6b6b';ctx.lineWidth=1.5;ctx.beginPath();
energyHist.forEach((e,i)=>{let x=325+i*(chw-10)/100,y=chy+22+(1-(e-mn)/(mx2-mn))*(chh-10);i?ctx.lineTo(x,y):ctx.moveTo(x,y)});ctx.stroke()}
ctx.fillStyle='#7d7a8c';ctx.font='400 8px Fira Code';
ctx.fillText('Green = positive weight (agree)',310,chy+chh+24);ctx.fillText('Red = negative weight (disagree)',310,chy+chh+35);
// Bottom
ctx.fillStyle='rgba(6,6,12,.85)';ctx.beginPath();ctx.roundRect(15,280,720,32,6);ctx.fill();
ctx.fillStyle='#a78bfa';ctx.font='500 9px Fira Code';
ctx.fillText('P(state) ‚àù exp(‚àíE/T). Low T = freezes into low-energy states. High T = random exploration.',25,300)}
c.onclick=e=>{let r2=c.getBoundingClientRect(),mx2=(e.clientX-r2.left)*750/r2.width,my=(e.clientY-r2.top)*320/r2.height;
for(let i=0;i<N;i++){let a=i/N*TAU-Math.PI/2,x=180+Math.cos(a)*100,y=148+Math.sin(a)*100;
if(dist(mx2,my,x,y)<22){states2[i]=1-states2[i];energyHist.push(energy());draw();return}}};
const ctrl=addControls(el);
ctrl.innerHTML='<label>Temp</label><input type="range" min="1" max="50" value="20" id="bt"><span id="btv" class="btn" style="min-width:30px;text-align:center">2.0</span>';
$('bt').oninput=e=>{temp=e.target.value/10;$('btv').textContent=temp.toFixed(1);draw()};
const sb=document.createElement('button');sb.className='btn';sb.textContent='‚ñ∂ Sample √ó10';sb.onclick=()=>{for(let i=0;i<10;i++)gibbsStep();draw()};
let tmr=null;const ab=document.createElement('button');ab.className='btn';ab.textContent='‚è© Auto Sample';
ab.onclick=()=>{if(tmr){clearInterval(tmr);tmr=null;ab.classList.remove('active')}else{tmr=setInterval(()=>{gibbsStep();draw()},50);ab.classList.add('active')}};
const rst=document.createElement('button');rst.className='btn';rst.textContent='‚Üª Reset';
rst.onclick=()=>{states2=Array(N).fill(0).map(()=>Math.random()>.5?1:0);energyHist=[];temp=2;$('bt').value=20;$('btv').textContent='2.0';if(tmr){clearInterval(tmr);tmr=null;ab.classList.remove('active')}draw()};
ctrl.appendChild(sb);ctrl.appendChild(ab);ctrl.appendChild(rst);draw()})();

// ===== BACKPROPAGATION ‚Äî XOR learning =====
(function(){const el=$('demo-bp'),[c,ctx]=createCanvas(el,750,340);
addHint(el,'Watch a 2-layer neural net learn XOR (the problem Perceptrons can\'t solve!). See gradients flow backward.');
const data=[{x:[0,0],y:0},{x:[0,1],y:1},{x:[1,0],y:1},{x:[1,1],y:0}];
let w1=Array(3).fill(0).map(()=>[rand(-.5,.5),rand(-.5,.5)]);
let b1=Array(3).fill(0).map(()=>rand(-.3,.3));
let w2=[rand(-.5,.5),rand(-.5,.5),rand(-.5,.5)];let b2=rand(-.3,.3);
let lr3=0.8,epoch=0,losses=[],lastGrads=[];
function forward(x){let h=w1.map((w,i)=>Math.max(0,w[0]*x[0]+w[1]*x[1]+b1[i]));
let o=w2[0]*h[0]+w2[1]*h[1]+w2[2]*h[2]+b2;o=1/(1+Math.exp(-o));return{h,o}}
function trainStep(){let totalLoss=0;let grads=w2.map(()=>0);
data.forEach(d=>{let{h,o}=forward(d.x);let err=o-d.y;totalLoss+=err*err;
let dOut=err*o*(1-o);
w2.forEach((w,i)=>{let dw=dOut*h[i];w2[i]-=lr3*dw;grads[i]+=Math.abs(dw)});b2-=lr3*dOut;
w1.forEach((w,i)=>{let dh=dOut*w2[i]*(h[i]>0?1:0);w[0]-=lr3*dh*d.x[0];w[1]-=lr3*dh*d.x[1];b1[i]-=lr3*dh})});
epoch++;losses.push(totalLoss/4);if(losses.length>300)losses.shift();lastGrads=grads}
function draw(){ctx.clearRect(0,0,750,340);
// Network
let nx=[85,305,540],ny=168;
let inY=[ny-50,ny+50];let hidY=[ny-70,ny,ny+70];
let np=[[],[]];inY.forEach(y=>np[0].push({x:nx[0],y}));hidY.forEach(y=>np[1].push({x:nx[1],y}));
np[2]=[{x:nx[2],y:ny}];
// Connections
for(let l=0;l<2;l++){let from=np[l],to=np[l+1];
from.forEach((f,fi)=>to.forEach((t,ti)=>{
let wv=l===0?w1[ti][fi]:w2[fi];let absW=Math.abs(wv);
ctx.strokeStyle=wv>0?`rgba(78,205,196,${Math.min(absW*1.5,.8)})`:`rgba(255,107,107,${Math.min(absW*1.5,.8)})`;
ctx.lineWidth=1+absW*3;ctx.beginPath();ctx.moveTo(f.x,f.y);ctx.lineTo(t.x,t.y);ctx.stroke()}))}
// Backward gradient arrows
if(lastGrads.length){np[1].forEach((h,i)=>{let t=np[2][0];
let g=Math.min(lastGrads[i]*20,1);
ctx.strokeStyle=`rgba(255,209,102,${g})`;ctx.lineWidth=2;ctx.setLineDash([4,4]);
ctx.beginPath();ctx.moveTo(t.x-20,t.y+(i-1)*5);ctx.lineTo(h.x+20,h.y);ctx.stroke();ctx.setLineDash([])})}
// Nodes
let labels=[['x‚ÇÅ','x‚ÇÇ'],['h‚ÇÅ','h‚ÇÇ','h‚ÇÉ'],['≈∑']];
[np[0],np[1],np[2]].forEach((layer,li)=>layer.forEach((n,ni)=>{
ctx.save();ctx.shadowColor=li===2?'#ff6b6b':'#4ecdc4';ctx.shadowBlur=8;
ctx.beginPath();ctx.arc(n.x,n.y,20,0,TAU);ctx.fillStyle=li===0?'#38bdf822':li===1?'#4ecdc422':'#ff6b6b22';ctx.fill();
ctx.strokeStyle=li===0?'#38bdf8':li===1?'#4ecdc4':'#ff6b6b';ctx.lineWidth=2;ctx.stroke();ctx.restore();
ctx.fillStyle='#e4e2df';ctx.font='600 10px Fira Code';ctx.textAlign='center';ctx.fillText(labels[li][ni],n.x,n.y+4);ctx.textAlign='left'}));
// Layer labels
ctx.fillStyle='#38bdf8';ctx.font='500 9px Fira Code';ctx.textAlign='center';
ctx.fillText('Input',nx[0],ny+100);ctx.fillStyle='#4ecdc4';ctx.fillText('Hidden (ReLU)',nx[1],ny+100);
ctx.fillStyle='#ff6b6b';ctx.fillText('Output (œÉ)',nx[2],ny+100);ctx.textAlign='left';
// XOR table
let tx=15,ty=12;ctx.fillStyle='rgba(6,6,12,.88)';ctx.beginPath();ctx.roundRect(tx,ty,205,100,8);ctx.fill();
ctx.fillStyle='#ffd166';ctx.font='600 11px Fira Code';ctx.fillText('XOR Truth vs Prediction:',tx+8,ty+18);
data.forEach((d,i)=>{let{o}=forward(d.x);let correct=Math.abs(o-d.y)<.3;
ctx.fillStyle=correct?'#34d399':'#ff6b6b';ctx.font='500 9px Fira Code';
ctx.fillText(d.x[0]+','+d.x[1]+' ‚Üí target:'+d.y+' pred:'+o.toFixed(2)+(correct?' ‚úì':' ‚úó'),tx+8,ty+36+i*16)});
// Loss curve
let lx=590,lw=150,lh=80;
ctx.fillStyle='rgba(6,6,12,.88)';ctx.beginPath();ctx.roundRect(lx,ty,lw,lh+15,8);ctx.fill();
ctx.fillStyle='#ff6b6b';ctx.font='600 10px Fira Code';ctx.fillText('Loss',lx+8,ty+16);
ctx.fillStyle='#7d7a8c';ctx.font='400 9px Fira Code';ctx.fillText('Epoch '+epoch,lx+50,ty+16);
if(losses.length>1){let mx2=Math.max(...losses),mn=Math.min(...losses);if(mx2===mn)mx2=mn+1;
ctx.strokeStyle='#ff6b6b';ctx.lineWidth=1.5;ctx.beginPath();
losses.forEach((l,i)=>{let x2=lx+5+i*(lw-10)/300,y=ty+25+(1-(l-mn)/(mx2-mn))*(lh-15);i?ctx.lineTo(x2,y):ctx.moveTo(x2,y)});ctx.stroke()}
// Bottom
ctx.fillStyle='rgba(6,6,12,.85)';ctx.beginPath();ctx.roundRect(15,288,720,45,8);ctx.fill();
ctx.fillStyle='#ffd166';ctx.font='600 10px Fira Code';ctx.fillText('‚ñ∂ Forward: input ‚Üí hidden ‚Üí output ‚Üí loss',25,306);
ctx.fillStyle='#ff6b6b';ctx.fillText('‚óÄ Backward: loss ‚Üí ‚àÇL/‚àÇw‚ÇÇ ‚Üí ‚àÇL/‚àÇh ‚Üí ‚àÇL/‚àÇw‚ÇÅ (yellow dashes = gradient flow)',25,324)}
const ctrl=addControls(el);
const tb=document.createElement('button');tb.className='btn';tb.textContent='‚ñ∂ Train √ó10';tb.onclick=()=>{for(let i=0;i<10;i++)trainStep();draw()};
let tmr=null;const ab=document.createElement('button');ab.className='btn';ab.textContent='‚è© Auto Train';
ab.onclick=()=>{if(tmr){clearInterval(tmr);tmr=null;ab.classList.remove('active')}else{tmr=setInterval(()=>{trainStep();draw()},40);ab.classList.add('active')}};
const rst=document.createElement('button');rst.className='btn';rst.textContent='‚Üª Reset';
rst.onclick=()=>{w1=Array(3).fill(0).map(()=>[rand(-.5,.5),rand(-.5,.5)]);b1=Array(3).fill(0).map(()=>rand(-.3,.3));
w2=[rand(-.5,.5),rand(-.5,.5),rand(-.5,.5)];b2=rand(-.3,.3);epoch=0;losses=[];lastGrads=[];
if(tmr){clearInterval(tmr);tmr=null;ab.classList.remove('active')}draw()};
ctrl.appendChild(tb);ctrl.appendChild(ab);ctrl.appendChild(rst);draw()})();

// ===== DECISION TREE =====
(function(){const el=$('demo-tree'),[c,ctx]=createCanvas(el,750,320);
addHint(el,'Click "Grow" to add splits. The tree recursively finds the best feature to split on at each node.');
let pts=[];function seedPts(){pts=[];for(let i=0;i<20;i++){pts.push({x:rand(20,350),y:rand(20,280),c:0});pts.push({x:rand(400,730),y:rand(20,280),c:1})}
for(let i=0;i<6;i++){pts.push({x:rand(300,450),y:rand(20,140),c:0});pts.push({x:rand(300,450),y:rand(150,280),c:1})}}
seedPts();let splits=[];
function findBestSplit(points){if(points.length<4)return null;
let bestGini=1,bestSplit=null;
['x','y'].forEach(axis=>{let vals=[...new Set(points.map(p=>p[axis]))].sort((a,b)=>a-b);
for(let i=1;i<vals.length;i++){let mid=(vals[i-1]+vals[i])/2;
let left=points.filter(p=>p[axis]<=mid),right=points.filter(p=>p[axis]>mid);
if(left.length<2||right.length<2)continue;
let gL=1-Math.pow(left.filter(p=>p.c===0).length/left.length,2)-Math.pow(left.filter(p=>p.c===1).length/left.length,2);
let gR=1-Math.pow(right.filter(p=>p.c===0).length/right.length,2)-Math.pow(right.filter(p=>p.c===1).length/right.length,2);
let gini=(left.length*gL+right.length*gR)/points.length;
if(gini<bestGini){bestGini=gini;bestSplit={axis,value:mid,gini}}}});
return bestSplit}
function growTree(){let split=findBestSplit(pts);if(split)splits.push(split);draw()}
function draw(){ctx.clearRect(0,0,750,320);
// Split lines
splits.forEach(s=>{ctx.strokeStyle='#ffd166';ctx.lineWidth=2;ctx.setLineDash([6,4]);ctx.beginPath();
if(s.axis==='x'){ctx.moveTo(s.value,0);ctx.lineTo(s.value,280)}
else{ctx.moveTo(0,s.value);ctx.lineTo(750,s.value)}
ctx.stroke();ctx.setLineDash([]);
ctx.fillStyle='rgba(6,6,12,.75)';ctx.beginPath();ctx.roundRect(s.axis==='x'?s.value+4:5,s.axis==='y'?s.value+4:5,60,16,3);ctx.fill();
ctx.fillStyle='#ffd166';ctx.font='500 9px Fira Code';ctx.fillText(s.axis+'<'+s.value.toFixed(0),s.axis==='x'?s.value+7:8,s.axis==='y'?s.value+16:18)});
// Points
pts.forEach(p=>{ctx.save();ctx.shadowColor=p.c?'#38bdf8':'#ff6b6b';ctx.shadowBlur=4;
ctx.beginPath();ctx.arc(p.x,p.y,5,0,TAU);ctx.fillStyle=p.c?'#38bdf8':'#ff6b6b';ctx.fill();ctx.restore()});
// Tree panel
let tx2=500,ty=10;ctx.fillStyle='rgba(6,6,12,.9)';ctx.beginPath();ctx.roundRect(tx2,ty,240,200,10);ctx.fill();
ctx.strokeStyle='#1e1e32';ctx.beginPath();ctx.roundRect(tx2,ty,240,200,10);ctx.stroke();
ctx.fillStyle='#ffd166';ctx.font='600 11px Fira Code';ctx.fillText('Decision Tree:',tx2+10,ty+22);
if(splits.length===0){ctx.fillStyle='#7d7a8c';ctx.font='400 9px Fira Code';ctx.fillText('Press Grow to start',tx2+10,ty+50)}
else{splits.forEach((s,i)=>{let y=ty+40+i*28;let indent=10+i*15;
ctx.fillStyle='#ffd166';ctx.font='500 9px Fira Code';
ctx.fillText((i>0?'‚îî‚îÄ ':'')+'if '+s.axis+' < '+s.value.toFixed(0),tx2+indent,y);
ctx.fillStyle='#7d7a8c';ctx.font='400 8px Fira Code';ctx.fillText('gini='+s.gini.toFixed(3),tx2+indent+115,y)})}
// Accuracy
let correct=pts.filter(p=>{let pred=0;if(splits.length>0){pred=p[splits[0].axis]>splits[0].value?1:0}return pred===p.c}).length;
ctx.fillStyle='#34d399';ctx.font='600 11px Fira Code';ctx.fillText('Accuracy: '+(correct/pts.length*100).toFixed(0)+'%',tx2+10,ty+190);
// Bottom info
ctx.fillStyle='rgba(6,6,12,.85)';ctx.beginPath();ctx.roundRect(15,288,470,26,6);ctx.fill();
ctx.fillStyle='#7d7a8c';ctx.font='400 9px Fira Code';ctx.fillText('Each split finds the feature + threshold that best separates classes (min Gini).',25,305)}
const ctrl=addControls(el);
const gb=document.createElement('button');gb.className='btn';gb.textContent='üå≥ Grow';gb.onclick=growTree;
const rst=document.createElement('button');rst.className='btn';rst.textContent='‚Üª Reset';
rst.onclick=()=>{splits=[];seedPts();draw()};
ctrl.appendChild(gb);ctrl.appendChild(rst);draw()})();
</script></body></html>
